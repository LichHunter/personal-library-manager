{"original_content": "Version Control For critical workflows: - Export YAML definitions regularly - Store in version control (Git) - Use pull requests for changes - Tag releases with semantic versioning ## Common Workflow Patterns Here are proven patterns for common automation scenarios: ### Pattern 1: Form to Database Capture form submissions and store in database: ```yaml name: \"Contact Form to Database\" trigger: type: webhook method: POST steps: - id: validate_submission action: javascript code: | if (!input.email || !input.message) { throw new Error(\"Email and message required\"); } return input; - id: check_duplicate action: database_query config: connection: \"{{secrets.DB_CONNECTION}}\" query: \"SELECT id FROM contacts WHERE email = $1 AND created_at > NOW() - INTERVAL '1 hour'\" parameters: - \"{{trigger.body.email}}\" - id: insert_contact action: database_query condition: \"{{length(steps.check_duplicate.rows) == 0}}\" config: connection: \"{{secrets.DB_CONNECTION}}\" query: | INSERT INTO contacts (name, email, message, source, created_at) VALUES ($1, $2, $3, $4, NOW()) parameters: - \"{{trigger.body.name}}\" - \"{{trigger.body.email}}\" - \"{{trigger.body.message}}\" - \"website_form\" - id: notify_sales action: slack_message condition: \"{{steps.insert_contact.affected_rows > 0}}\" config: channel: \"#leads\" text: \"New contact form submission from {{trigger.body.email}}\" ``` ### Pattern 2: API Polling Periodically check an API and take action on new items: ```yaml name: \"Poll GitHub Issues\" schedule: cron: \"*/15 * * * *\" # Every 15 minutes timezone: \"UTC\" steps: - id: get_last_check action: database_query config: query: \"SELECT last_checked_at FROM workflow_state WHERE workflow_id = $1\" parameters: - \"{{workflow.id}}\" - id: fetch_issues action: http_request config: method: GET url: \"https://api.github.com/repos/company/project/issues\" params: since: \"{{steps.get_last_check.rows[0].last_checked_at}}\" state: \"open\" headers: Authorization: \"token {{secrets.GITHUB_TOKEN}}\" - id: process_new_issues action: javascript code: | const issues = input.body; return { count: issues.length, issues: issues.map(i => ({ number: i.number, title: i.title, url: i.html_url })) }; - id: notify_team action: slack_message condition: \"{{steps.process_new_issues.output.count > 0}}\" config: channel: \"#engineering\" text: \"{{steps.process_new_issues.output.count}} new GitHub issues\" - id: update_last_check action: database_query config: query: | UPDATE workflow_state SET last_checked_at = $1 WHERE workflow_id = $2 parameters: - \"{{now()}}\" - \"{{workflow.id}}\" ``` ### Pattern 3: Multi-Step Approval Implement approval workflows with timeouts: ```yaml name: \"Expense Approval Workflow\" trigger: type: webhook method: POST steps: - id: create_approval_request action: database_query config: query: | INSERT INTO approvals (expense_id, amount, requester, status, created_at) VALUES ($1, $2, $3, 'pending', NOW()) RETURNING id parameters: - \"{{trigger.body.expense_id}}\" - \"{{trigger.body.amount}}\" - \"{{trigger.body.requester}}\" - id: notify_manager action: email config: to: \"{{trigger.body.manager_email}}\" subject: \"Expense Approval Required: ${{trigger.body.amount}}\" body: | An expense requires your approval: Amount: ${{trigger.body.amount}}", "enhanced_content": "Polling Periodically, API Polling, Version Control, Expense Approval, Export YAML, POST steps, Approval Required | Git, API, Multi-Step Approval Implement, Expense Approval Workflow, Expense Approval Required:\n\nVersion Control For critical workflows: - Export YAML definitions regularly - Store in version control (Git) - Use pull requests for changes - Tag releases with semantic versioning ## Common Workflow Patterns Here are proven patterns for common automation scenarios: ### Pattern 1: Form to Database Capture form submissions and store in database: ```yaml name: \"Contact Form to Database\" trigger: type: webhook method: POST steps: - id: validate_submission action: javascript code: | if (!input.email || !input.message) { throw new Error(\"Email and message required\"); } return input; - id: check_duplicate action: database_query config: connection: \"{{secrets.DB_CONNECTION}}\" query: \"SELECT id FROM contacts WHERE email = $1 AND created_at > NOW() - INTERVAL '1 hour'\" parameters: - \"{{trigger.body.email}}\" - id: insert_contact action: database_query condition: \"{{length(steps.check_duplicate.rows) == 0}}\" config: connection: \"{{secrets.DB_CONNECTION}}\" query: | INSERT INTO contacts (name, email, message, source, created_at) VALUES ($1, $2, $3, $4, NOW()) parameters: - \"{{trigger.body.name}}\" - \"{{trigger.body.email}}\" - \"{{trigger.body.message}}\" - \"website_form\" - id: notify_sales action: slack_message condition: \"{{steps.insert_contact.affected_rows > 0}}\" config: channel: \"#leads\" text: \"New contact form submission from {{trigger.body.email}}\" ``` ### Pattern 2: API Polling Periodically check an API and take action on new items: ```yaml name: \"Poll GitHub Issues\" schedule: cron: \"*/15 * * * *\" # Every 15 minutes timezone: \"UTC\" steps: - id: get_last_check action: database_query config: query: \"SELECT last_checked_at FROM workflow_state WHERE workflow_id = $1\" parameters: - \"{{workflow.id}}\" - id: fetch_issues action: http_request config: method: GET url: \"https://api.github.com/repos/company/project/issues\" params: since: \"{{steps.get_last_check.rows[0].last_checked_at}}\" state: \"open\" headers: Authorization: \"token {{secrets.GITHUB_TOKEN}}\" - id: process_new_issues action: javascript code: | const issues = input.body; return { count: issues.length, issues: issues.map(i => ({ number: i.number, title: i.title, url: i.html_url })) }; - id: notify_team action: slack_message condition: \"{{steps.process_new_issues.output.count > 0}}\" config: channel: \"#engineering\" text: \"{{steps.process_new_issues.output.count}} new GitHub issues\" - id: update_last_check action: database_query config: query: | UPDATE workflow_state SET last_checked_at = $1 WHERE workflow_id = $2 parameters: - \"{{now()}}\" - \"{{workflow.id}}\" ``` ### Pattern 3: Multi-Step Approval Implement approval workflows with timeouts: ```yaml name: \"Expense Approval Workflow\" trigger: type: webhook method: POST steps: - id: create_approval_request action: database_query config: query: | INSERT INTO approvals (expense_id, amount, requester, status, created_at) VALUES ($1, $2, $3, 'pending', NOW()) RETURNING id parameters: - \"{{trigger.body.expense_id}}\" - \"{{trigger.body.amount}}\" - \"{{trigger.body.requester}}\" - id: notify_manager action: email config: to: \"{{trigger.body.manager_email}}\" subject: \"Expense Approval Required: ${{trigger.body.amount}}\" body: | An expense requires your approval: Amount: ${{trigger.body.amount}}", "enrichment_type": "fast", "metadata": {"code_ratio": 0.66, "processing_time_ms": 41.13, "keyword_count": 10, "entity_count": 6}, "keywords": ["Polling Periodically", "API Polling", "Version Control", "Expense Approval", "Export YAML", "POST steps", "Approval Required", "Capture form", "Tag releases", "Approval Implement"], "questions": [], "summary": "", "entities": {"PERSON": ["Git"], "ORG": ["API", "Multi-Step Approval Implement", "expense_id"], "WORK_OF_ART": ["Expense Approval Workflow", "Expense Approval Required:"]}, "contextual_prefix": ""}