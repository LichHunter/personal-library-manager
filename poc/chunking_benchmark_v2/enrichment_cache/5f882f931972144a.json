{"original_content": "### Cache Invalidation Strategies **Time-Based Expiration (TTL)**: - Short-lived data: 5-15 minutes (session tokens, rate limit counters) - Medium-lived data: 1 hour (workflow definitions, templates) - Long-lived data: 24 hours (static configuration) **Event-Based Invalidation**: ``` Database Update Event \u2192 Kafka (cache.invalidation topic) \u2502 \u25bc All service instances consume event \u2502 \u25bc Redis DEL for affected keys ``` **Pattern-Based Invalidation**: - Use Redis SCAN + DEL for wildcard patterns - Example: Invalidate all user caches: `user:*:{user_id}` **Cache Warming**: - Scheduled job runs every hour to pre-populate frequently accessed data - Targets: Top 1000 workflows, system configuration, active user profiles - Reduces cache miss rate during traffic spikes ### Multi-Level Caching Application implements L1 (in-memory) and L2 (Redis) caching: ``` Request \u2192 L1 Cache (Node.js Map, 1000 entry LRU) \u2502 MISS \u2502 \u25bc L2 Cache (Redis, distributed) \u2502 MISS \u2502 \u25bc Database (PostgreSQL) ``` L1 cache reduces Redis network calls by 40% for hot data. --- ## Security Architecture ### Network Security **Zero-Trust Network Model**: - All service-to-service communication encrypted with mTLS - Certificate rotation: Every 90 days (automated via cert-manager) - Certificate authority: Internal PKI with HashiCorp Vault - Network segmentation: Private subnets for services, public subnet for ALB only **Service Mesh (Istio)**: ``` Service A \u2192 Envoy Sidecar (mTLS client cert) \u2502 Encrypted channel \u2502 Envoy Sidecar (mTLS server cert) \u2192 Service B ``` **Firewall Rules**: - Security groups: Deny all by default, explicit allow rules - Ingress: Only ALB can reach API Gateway (port 8080) - Egress: Services can only reach specific dependencies - Database access: Limited to application subnets only ### Authentication & Authorization **JWT Token Validation**: - Algorithm: RS256 (asymmetric signing) - Key rotation: Every 30 days with 7-day overlap period - Public key distribution: JWKS endpoint cached in Redis - Validation: Signature, expiry, issuer, audience claims - Token revocation: Blacklist in Redis for compromised tokens **Permission Model**: ``` User \u2192 Roles \u2192 Permissions \u2198 \u2197 Tenants (Multi-tenancy isolation) ``` Example permissions: - `workflow:read` - View workflows - `workflow:write` - Create/update workflows - `workflow:execute` - Trigger workflow execution - `workflow:delete` - Delete workflows - `admin:*` - All administrative operations **API Key Management**: - Format: `cfk_live_<32-char-random>` (production), `cfk_test_<32-char-random>` (sandbox) - Hashing: SHA-256 before storage in PostgreSQL - Scoping: API keys can be scoped to specific workflows or operations - Rate limits: Configurable", "enhanced_content": "Node.js Map, Invalidation Strategies, Cache Warming, Cache Invalidation, Short-lived data, Medium-lived data, Long-lived data | TTL, `user:*:{user_id}` **, Kafka, Redis DEL, mTLS\n\n### Cache Invalidation Strategies **Time-Based Expiration (TTL)**: - Short-lived data: 5-15 minutes (session tokens, rate limit counters) - Medium-lived data: 1 hour (workflow definitions, templates) - Long-lived data: 24 hours (static configuration) **Event-Based Invalidation**: ``` Database Update Event \u2192 Kafka (cache.invalidation topic) \u2502 \u25bc All service instances consume event \u2502 \u25bc Redis DEL for affected keys ``` **Pattern-Based Invalidation**: - Use Redis SCAN + DEL for wildcard patterns - Example: Invalidate all user caches: `user:*:{user_id}` **Cache Warming**: - Scheduled job runs every hour to pre-populate frequently accessed data - Targets: Top 1000 workflows, system configuration, active user profiles - Reduces cache miss rate during traffic spikes ### Multi-Level Caching Application implements L1 (in-memory) and L2 (Redis) caching: ``` Request \u2192 L1 Cache (Node.js Map, 1000 entry LRU) \u2502 MISS \u2502 \u25bc L2 Cache (Redis, distributed) \u2502 MISS \u2502 \u25bc Database (PostgreSQL) ``` L1 cache reduces Redis network calls by 40% for hot data. --- ## Security Architecture ### Network Security **Zero-Trust Network Model**: - All service-to-service communication encrypted with mTLS - Certificate rotation: Every 90 days (automated via cert-manager) - Certificate authority: Internal PKI with HashiCorp Vault - Network segmentation: Private subnets for services, public subnet for ALB only **Service Mesh (Istio)**: ``` Service A \u2192 Envoy Sidecar (mTLS client cert) \u2502 Encrypted channel \u2502 Envoy Sidecar (mTLS server cert) \u2192 Service B ``` **Firewall Rules**: - Security groups: Deny all by default, explicit allow rules - Ingress: Only ALB can reach API Gateway (port 8080) - Egress: Services can only reach specific dependencies - Database access: Limited to application subnets only ### Authentication & Authorization **JWT Token Validation**: - Algorithm: RS256 (asymmetric signing) - Key rotation: Every 30 days with 7-day overlap period - Public key distribution: JWKS endpoint cached in Redis - Validation: Signature, expiry, issuer, audience claims - Token revocation: Blacklist in Redis for compromised tokens **Permission Model**: ``` User \u2192 Roles \u2192 Permissions \u2198 \u2197 Tenants (Multi-tenancy isolation) ``` Example permissions: - `workflow:read` - View workflows - `workflow:write` - Create/update workflows - `workflow:execute` - Trigger workflow execution - `workflow:delete` - Delete workflows - `admin:*` - All administrative operations **API Key Management**: - Format: `cfk_live_<32-char-random>` (production), `cfk_test_<32-char-random>` (sandbox) - Hashing: SHA-256 before storage in PostgreSQL - Scoping: API keys can be scoped to specific workflows or operations - Rate limits: Configurable", "enrichment_type": "fast", "metadata": {"code_ratio": 0.22, "processing_time_ms": 91.27, "keyword_count": 10, "entity_count": 15}, "keywords": ["Node.js Map", "Invalidation Strategies", "Cache Warming", "Cache Invalidation", "Short-lived data", "Medium-lived data", "Long-lived data", "cache miss", "Redis DEL", "Redis SCAN"], "questions": [], "summary": "", "entities": {"ORG": ["TTL", "`user:*:{user_id}` **", "Multi-Level Caching Application", "LRU", "PKI"], "PERSON": ["Kafka", "Redis DEL", "L2 Cache", "Database", "Redis"], "GPE": ["mTLS", "Redis", "PostgreSQL"], "PRODUCT": ["API Gateway", "RS256"]}, "contextual_prefix": ""}