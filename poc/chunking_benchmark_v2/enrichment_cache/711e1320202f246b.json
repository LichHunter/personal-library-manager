{"original_content": "Deploy PostgreSQL using the Bitnami Helm chart: ```yaml # postgres-values.yaml global: postgresql: auth: username: cloudflow database: cloudflow existingSecret: postgres-credentials image: tag: \"14.10.0\" primary: resources: limits: cpu: 4000m memory: 8Gi requests: cpu: 2000m memory: 4Gi persistence: enabled: true size: 100Gi storageClass: gp3 extendedConfiguration: | max_connections = 100 shared_buffers = 2GB effective_cache_size = 6GB maintenance_work_mem = 512MB checkpoint_completion_target = 0.9 wal_buffers = 16MB default_statistics_target = 100 random_page_cost = 1.1 effective_io_concurrency = 200 work_mem = 10MB min_wal_size = 1GB max_wal_size = 4GB readReplicas: replicaCount: 2 resources: limits: cpu: 2000m memory: 4Gi requests: cpu: 1000m memory: 2Gi metrics: enabled: true serviceMonitor: enabled: true ``` Install PostgreSQL: ```bash # Create password secret kubectl create secret generic postgres-credentials \\ --namespace cloudflow-prod \\ --from-literal=postgres-password=\"$(openssl rand -base64 32)\" \\ --from-literal=password=\"$(openssl rand -base64 32)\" # Install PostgreSQL helm install postgresql bitnami/postgresql \\ --namespace cloudflow-prod \\ --values postgres-values.yaml \\ --wait ``` ### PgBouncer Configuration Deploy PgBouncer for connection pooling to handle up to 100 connections efficiently: ```yaml # pgbouncer.yaml apiVersion: v1 kind: ConfigMap metadata: name: pgbouncer-config namespace: cloudflow-prod data: pgbouncer.ini: | [databases] cloudflow = host=postgresql.cloudflow-prod.svc.cluster.local port=5432 dbname=cloudflow [pgbouncer] listen_addr = 0.0.0.0 listen_port = 5432 auth_type = md5 auth_file = /etc/pgbouncer/userlist.txt pool_mode = transaction max_client_conn = 1000 default_pool_size = 25 reserve_pool_size = 5 reserve_pool_timeout = 3 max_db_connections = 100 max_user_connections = 100 server_lifetime = 3600 server_idle_timeout = 600 log_connections = 1 log_disconnections = 1 log_pooler_errors = 1 --- apiVersion: apps/v1 kind: Deployment metadata: name: pgbouncer namespace: cloudflow-prod spec: replicas: 2 selector: matchLabels: app: pgbouncer template: metadata: labels: app: pgbouncer spec: containers: - name: pgbouncer image: pgbouncer/pgbouncer:1.21.0 ports: - containerPort: 5432 resources: requests: cpu: 500m memory: 512Mi limits: cpu: 1000m memory: 1Gi volumeMounts: - name: config mountPath: /etc/pgbouncer volumes: - name: config configMap: name: pgbouncer-config --- apiVersion: v1 kind: Service metadata: name: pgbouncer namespace: cloudflow-prod spec: selector: app: pgbouncer ports: - port: 5432 targetPort: 5432 type: ClusterIP ``` Apply the PgBouncer configuration: ```bash kubectl apply -f pgbouncer.yaml ``` ### Database Migrations Run database migrations before deploying new versions: ```bash # Create migration job kubectl create job cloudflow-migrate-$(date +%s) \\ --namespace cloudflow-prod \\ --image=123456789012.dkr.ecr.us-east-1.amazonaws.com/cloudflow:2.4.0 \\ -- npm run migrate # Monitor migration progress kubectl logs -f job/cloudflow-migrate-<timestamp> -n cloudflow-prod ``` --- ## Monitoring and Observability ### Prometheus Setup Install Prometheus using the kube-prometheus-stack: ```bash helm install prometheus prometheus-community/kube-prometheus-stack \\ --namespace monitoring \\ --create-namespace \\ --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \\", "enhanced_content": "Database Migrations, Install Prometheus, Migrations Run, Run database, Prometheus Setup, Setup Install, Bitnami Helm | Deploy PostgreSQL, the Bitnami Helm, PgBouncer\n\nDeploy PostgreSQL using the Bitnami Helm chart: ```yaml # postgres-values.yaml global: postgresql: auth: username: cloudflow database: cloudflow existingSecret: postgres-credentials image: tag: \"14.10.0\" primary: resources: limits: cpu: 4000m memory: 8Gi requests: cpu: 2000m memory: 4Gi persistence: enabled: true size: 100Gi storageClass: gp3 extendedConfiguration: | max_connections = 100 shared_buffers = 2GB effective_cache_size = 6GB maintenance_work_mem = 512MB checkpoint_completion_target = 0.9 wal_buffers = 16MB default_statistics_target = 100 random_page_cost = 1.1 effective_io_concurrency = 200 work_mem = 10MB min_wal_size = 1GB max_wal_size = 4GB readReplicas: replicaCount: 2 resources: limits: cpu: 2000m memory: 4Gi requests: cpu: 1000m memory: 2Gi metrics: enabled: true serviceMonitor: enabled: true ``` Install PostgreSQL: ```bash # Create password secret kubectl create secret generic postgres-credentials \\ --namespace cloudflow-prod \\ --from-literal=postgres-password=\"$(openssl rand -base64 32)\" \\ --from-literal=password=\"$(openssl rand -base64 32)\" # Install PostgreSQL helm install postgresql bitnami/postgresql \\ --namespace cloudflow-prod \\ --values postgres-values.yaml \\ --wait ``` ### PgBouncer Configuration Deploy PgBouncer for connection pooling to handle up to 100 connections efficiently: ```yaml # pgbouncer.yaml apiVersion: v1 kind: ConfigMap metadata: name: pgbouncer-config namespace: cloudflow-prod data: pgbouncer.ini: | [databases] cloudflow = host=postgresql.cloudflow-prod.svc.cluster.local port=5432 dbname=cloudflow [pgbouncer] listen_addr = 0.0.0.0 listen_port = 5432 auth_type = md5 auth_file = /etc/pgbouncer/userlist.txt pool_mode = transaction max_client_conn = 1000 default_pool_size = 25 reserve_pool_size = 5 reserve_pool_timeout = 3 max_db_connections = 100 max_user_connections = 100 server_lifetime = 3600 server_idle_timeout = 600 log_connections = 1 log_disconnections = 1 log_pooler_errors = 1 --- apiVersion: apps/v1 kind: Deployment metadata: name: pgbouncer namespace: cloudflow-prod spec: replicas: 2 selector: matchLabels: app: pgbouncer template: metadata: labels: app: pgbouncer spec: containers: - name: pgbouncer image: pgbouncer/pgbouncer:1.21.0 ports: - containerPort: 5432 resources: requests: cpu: 500m memory: 512Mi limits: cpu: 1000m memory: 1Gi volumeMounts: - name: config mountPath: /etc/pgbouncer volumes: - name: config configMap: name: pgbouncer-config --- apiVersion: v1 kind: Service metadata: name: pgbouncer namespace: cloudflow-prod spec: selector: app: pgbouncer ports: - port: 5432 targetPort: 5432 type: ClusterIP ``` Apply the PgBouncer configuration: ```bash kubectl apply -f pgbouncer.yaml ``` ### Database Migrations Run database migrations before deploying new versions: ```bash # Create migration job kubectl create job cloudflow-migrate-$(date +%s) \\ --namespace cloudflow-prod \\ --image=123456789012.dkr.ecr.us-east-1.amazonaws.com/cloudflow:2.4.0 \\ -- npm run migrate # Monitor migration progress kubectl logs -f job/cloudflow-migrate-<timestamp> -n cloudflow-prod ``` --- ## Monitoring and Observability ### Prometheus Setup Install Prometheus using the kube-prometheus-stack: ```bash helm install prometheus prometheus-community/kube-prometheus-stack \\ --namespace monitoring \\ --create-namespace \\ --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \\", "enrichment_type": "fast", "metadata": {"code_ratio": 0.82, "processing_time_ms": 24.84, "keyword_count": 10, "entity_count": 3}, "keywords": ["Database Migrations", "Install Prometheus", "Migrations Run", "Run database", "Prometheus Setup", "Setup Install", "Bitnami Helm", "prometheus prometheus-community", "PgBouncer Configuration", "Helm chart"], "questions": [], "summary": "", "entities": {"ORG": ["Deploy PostgreSQL"], "FAC": ["the Bitnami Helm"], "PERSON": ["PgBouncer"]}, "contextual_prefix": ""}