"""Cache integration for expensive operations in modular retrieval pipeline.

This module provides a CacheableComponent wrapper that adds caching to any
component without modifying the underlying implementation. It follows the
decorator pattern and implements the Component protocol for pipeline compatibility.

The wrapper uses hash-based cache keys (SHA256) to uniquely identify cached results
and supports both disk-based caching (default) and Redis backends (optional).

Example:
    >>> from base import Component
    >>> class ExpensiveComponent(Component):
    ...     def process(self, data: str) -> str:
    ...         # Expensive operation
    ...         return data.upper()
    ...
    >>> # Wrap with caching
    >>> cached = CacheableComponent(ExpensiveComponent(), cache_dir="cache")
    >>> result1 = cached.process("hello")  # Runs expensive operation, caches result
    >>> result2 = cached.process("hello")  # Returns cached result (fast)
"""

import hashlib
import json
import pickle
import time
from pathlib import Path
from typing import Any, Optional, Protocol, TypeVar, Generic, runtime_checkable

# Import Component protocol from base module
from .base import Component


InputT = TypeVar("InputT")
OutputT = TypeVar("OutputT")


class CacheBackend(Protocol):
    """Protocol for cache backends (disk, Redis, etc.)."""

    def get(self, key: str) -> Optional[Any]:
        """Retrieve cached value by key.

        Args:
            key: Cache key (typically a hash)

        Returns:
            Cached value or None if not found
        """
        ...

    def put(self, key: str, value: Any) -> None:
        """Store value in cache.

        Args:
            key: Cache key (typically a hash)
            value: Value to cache
        """
        ...

    def clear(self) -> int:
        """Clear all cached values.

        Returns:
            Number of items cleared
        """
        ...


class DiskCacheBackend:
    """Disk-based cache backend using JSON serialization.

    Stores cached results as JSON files in a directory. Uses pickle for
    serialization to support arbitrary Python objects.
    """

    def __init__(self, cache_dir: str = "cache"):
        """Initialize disk cache backend.

        Args:
            cache_dir: Directory to store cache files
        """
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _cache_path(self, key: str) -> Path:
        """Get file path for cache key.

        Args:
            key: Cache key (typically a hash)

        Returns:
            Path to cache file
        """
        return self.cache_dir / f"{key}.pkl"

    def get(self, key: str) -> Optional[Any]:
        """Retrieve cached value from disk.

        Args:
            key: Cache key

        Returns:
            Cached value or None if not found
        """
        path = self._cache_path(key)
        if not path.exists():
            return None

        try:
            with open(path, "rb") as f:
                return pickle.load(f)
        except (pickle.PickleError, EOFError):
            return None

    def put(self, key: str, value: Any) -> None:
        """Store value on disk.

        Args:
            key: Cache key
            value: Value to cache
        """
        path = self._cache_path(key)
        with open(path, "wb") as f:
            pickle.dump(value, f)

    def clear(self) -> int:
        """Clear all cached files.

        Returns:
            Number of files deleted
        """
        count = 0
        for path in self.cache_dir.glob("*.pkl"):
            path.unlink()
            count += 1
        return count


class CacheableComponent(Generic[InputT, OutputT]):
    """Wrapper that adds caching to any component.

    This decorator-pattern wrapper caches component outputs based on input hash.
    It implements the Component protocol so it can be used in pipelines just like
    any other component.

    The cache key is generated by hashing the input data (using SHA256), ensuring
    that identical inputs always produce the same cache key. This works for any
    serializable input type.

    Features:
    - Hash-based cache keys (SHA256)
    - Disk-based caching (default)
    - Redis backend support (optional)
    - Transparent integration with Component protocol
    - No modification to wrapped component

    Example:
        >>> class SlowComponent(Component):
        ...     def process(self, data: str) -> str:
        ...         time.sleep(0.1)  # Expensive operation
        ...         return data.upper()
        ...
        >>> slow = SlowComponent()
        >>> cached = CacheableComponent(slow, cache_dir="cache")
        >>>
        >>> # First call: runs component, caches result (~0.1s)
        >>> result1 = cached.process("hello")
        >>>
        >>> # Second call: returns cached result (~0.001s)
        >>> result2 = cached.process("hello")
    """

    def __init__(
        self,
        component: Component[InputT, OutputT],
        cache_dir: str = "cache",
        backend: Optional[CacheBackend] = None,
    ):
        """Initialize CacheableComponent wrapper.

        Args:
            component: Component to wrap with caching
            cache_dir: Directory for disk cache (ignored if backend provided)
            backend: Custom cache backend (defaults to DiskCacheBackend)
        """
        self.component = component
        self.backend = backend or DiskCacheBackend(cache_dir)

    def _make_cache_key(self, data: InputT) -> str:
        """Generate cache key from input data using SHA256 hash.

        The cache key is generated by:
        1. Serializing the input data to JSON (for simple types) or pickle
        2. Computing SHA256 hash of the serialized data
        3. Taking first 16 characters of hex digest for readability

        This ensures:
        - Identical inputs always produce the same key
        - Different inputs produce different keys (with high probability)
        - Keys are short and filesystem-safe

        Args:
            data: Input data to hash

        Returns:
            16-character hex string cache key

        Raises:
            TypeError: If data cannot be serialized
        """
        try:
            # Try JSON serialization first (works for simple types)
            serialized = json.dumps(data, sort_keys=True, default=str).encode()
        except (TypeError, ValueError):
            # Fall back to pickle for complex types
            serialized = pickle.dumps(data)

        # Compute SHA256 hash and take first 16 chars
        hash_digest = hashlib.sha256(serialized).hexdigest()
        return hash_digest[:16]

    def process(self, data: InputT) -> OutputT:
        """Process data with caching.

        Implements the Component protocol. On first call with given input,
        runs the wrapped component and caches the result. On subsequent calls
        with the same input, returns the cached result.

        Args:
            data: Input data

        Returns:
            Processed output (from cache or from wrapped component)

        Raises:
            Any exception raised by wrapped component
        """
        # Generate cache key from input
        cache_key = self._make_cache_key(data)

        # Try to get from cache
        cached_result = self.backend.get(cache_key)
        if cached_result is not None:
            return cached_result

        # Cache miss: run component
        result = self.component.process(data)

        # Store in cache
        self.backend.put(cache_key, result)

        return result

    def clear_cache(self) -> int:
        """Clear all cached values.

        Returns:
            Number of items cleared
        """
        return self.backend.clear()
