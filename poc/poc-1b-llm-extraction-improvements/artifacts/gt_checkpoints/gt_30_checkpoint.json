{
  "metadata": {
    "started_at": "2026-02-08T17:48:18.394544",
    "random_seed": 42,
    "target_chunks": 30,
    "model": "claude-opus-4-5-20251101",
    "total_cost_usd": 2.0008350000000004,
    "last_saved": "2026-02-08T21:06:25.430012"
  },
  "completed_chunks": [
    {
      "chunk_id": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions_sec0",
      "doc_id": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions",
      "heading": "Introduction",
      "source_file": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions.md",
      "content": "---\ntitle: Extend the Kubernetes API with CustomResourceDefinitions\nreviewers:\n- deads2k\n- jpbetz\n- liggitt\n- roycaihw\n- sttts\ncontent_type: task\nmin-kubernetes-server-version: 1.16\nweight: 20\n---\n\n<!-- overview -->\nThis page shows how to install a\n[custom resource](/docs/concepts/extend-kubernetes/api-extension/custom-resources/)\ninto the Kubernetes API by creating a\n[CustomResourceDefinition](/docs/reference/generated/kubernetes-api/{{< param \"version\" >}}/#customresourcedefinition-v1-apiextensions-k8s-io).",
      "terms": [
        {
          "term": "Kubernetes API",
          "tier": 1,
          "reasoning": "Core Kubernetes component that serves as the primary interface for cluster operations and resource management."
        },
        {
          "term": "CustomResourceDefinitions",
          "tier": 1,
          "reasoning": "Named Kubernetes API object used to extend the API with custom resources."
        },
        {
          "term": "CustomResourceDefinition",
          "tier": 1,
          "reasoning": "Singular form of the API object that defines custom resources in Kubernetes."
        },
        {
          "term": "custom resource",
          "tier": 2,
          "reasoning": "Domain concept referring to user-defined extensions to the Kubernetes API."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "General technical term for Application Programming Interface, contextually important for Kubernetes extension."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform that is the subject of this documentation."
        },
        {
          "term": "API extension",
          "tier": 2,
          "reasoning": "Domain concept describing the process of extending Kubernetes API capabilities."
        },
        {
          "term": "min-kubernetes-server-version",
          "tier": 3,
          "reasoning": "Metadata field indicating minimum Kubernetes version requirement for the feature."
        },
        {
          "term": "1.16",
          "tier": 3,
          "reasoning": "Specific Kubernetes version number referenced as minimum server version."
        },
        {
          "term": "apiextensions-k8s-io",
          "tier": 1,
          "reasoning": "Kubernetes API group that contains the CustomResourceDefinition resource."
        },
        {
          "term": "v1",
          "tier": 3,
          "reasoning": "API version indicator denoting stable API version in Kubernetes."
        }
      ],
      "term_count": 11,
      "generated_at": "2026-02-08T17:48:26.027045",
      "elapsed_time": 7.632281541824341
    },
    {
      "chunk_id": "concepts_workloads_management_sec10",
      "doc_id": "concepts_workloads_management",
      "heading": "In-place updates of resources",
      "source_file": "concepts_workloads_management.md",
      "content": "Sometimes it's necessary to make narrow, non-disruptive updates to resources you've created.\n\n### kubectl apply\n\nIt is suggested to maintain a set of configuration files in source control\n(see [configuration as code](https://martinfowler.com/bliki/InfrastructureAsCode.html)),\nso that they can be maintained and versioned along with the code for the resources they configure.\nThen, you can use [`kubectl apply`](/docs/reference/kubectl/generated/kubectl_apply/)\nto push your configuration changes to the cluster.\n\nThis command will compare the version of the configuration that you're pushing with the previous\nversion and apply the changes you've made, without overwriting any automated changes to properties\nyou haven't specified.\n\n```shell\nkubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml\n```\n\n```none\ndeployment.apps/my-nginx configured\n```\n\nTo learn more about the underlying mechanism, read [server-side apply](/docs/reference/using-api/server-side-apply/).\n\n### kubectl edit\n\nAlternatively, you may also update resources with [`kubectl edit`](/docs/reference/kubectl/generated/kubectl_edit/):\n\n```shell\nkubectl edit deployment/my-nginx\n```\n\nThis is equivalent to first `get` the resource, edit it in text editor, and then `apply` the\nresource with the updated version:\n\n```shell\nkubectl get deployment my-nginx -o yaml > /tmp/nginx.yaml\nvi /tmp/nginx.yaml",
      "terms": [
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command for applying configuration changes to cluster resources."
        },
        {
          "term": "kubectl edit",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command for editing resources directly."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "The official Kubernetes command-line tool referenced throughout the documentation."
        },
        {
          "term": "deployment",
          "tier": 1,
          "reasoning": "Kubernetes API object/resource type shown in examples (deployment.apps/my-nginx, deployment/my-nginx)."
        },
        {
          "term": "my-nginx",
          "tier": 1,
          "reasoning": "Specific named deployment resource used in the examples."
        },
        {
          "term": "nginx-deployment.yaml",
          "tier": 1,
          "reasoning": "Specific configuration file name referenced in the kubectl apply example."
        },
        {
          "term": "deployment.apps",
          "tier": 1,
          "reasoning": "Kubernetes API group and resource type shown in command output."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Domain concept referring to Kubernetes API objects that can be created and managed."
        },
        {
          "term": "configuration files",
          "tier": 2,
          "reasoning": "Technical concept referring to files that define Kubernetes resource specifications."
        },
        {
          "term": "source control",
          "tier": 2,
          "reasoning": "Technical concept for version control systems used to manage configuration."
        },
        {
          "term": "configuration as code",
          "tier": 2,
          "reasoning": "Infrastructure/DevOps concept explicitly referenced with link to Martin Fowler's definition."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Core Kubernetes architectural concept referring to the set of nodes running containerized applications."
        },
        {
          "term": "configuration changes",
          "tier": 2,
          "reasoning": "Domain concept describing modifications to resource specifications."
        },
        {
          "term": "server-side apply",
          "tier": 2,
          "reasoning": "Kubernetes-specific mechanism for applying configuration changes mentioned as underlying mechanism."
        },
        {
          "term": "automated changes",
          "tier": 2,
          "reasoning": "Concept referring to system-generated modifications to resource properties."
        },
        {
          "term": "properties",
          "tier": 2,
          "reasoning": "Technical term referring to resource specification fields/attributes."
        },
        {
          "term": "text editor",
          "tier": 3,
          "reasoning": "General technical tool referenced in the kubectl edit workflow."
        },
        {
          "term": "yaml",
          "tier": 3,
          "reasoning": "Data serialization format used for Kubernetes configuration files, shown in -o yaml flag."
        },
        {
          "term": "-o yaml",
          "tier": 2,
          "reasoning": "kubectl output format flag for retrieving resources in YAML format."
        },
        {
          "term": "get",
          "tier": 2,
          "reasoning": "kubectl subcommand operation for retrieving resources, referenced in workflow description."
        },
        {
          "term": "kubectl get",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command shown explicitly in the example."
        },
        {
          "term": "apply",
          "tier": 2,
          "reasoning": "Kubernetes operation for pushing configuration to cluster, used both as command and verb."
        },
        {
          "term": "version",
          "tier": 3,
          "reasoning": "Technical concept referring to configuration state comparison in apply operation."
        },
        {
          "term": "versioned",
          "tier": 3,
          "reasoning": "Technical concept describing configuration files maintained with version history."
        }
      ],
      "term_count": 24,
      "generated_at": "2026-02-08T17:48:41.104171",
      "elapsed_time": 14.076469421386719
    },
    {
      "chunk_id": "concepts_extend-kubernetes_operator_sec7",
      "doc_id": "concepts_extend-kubernetes_operator",
      "heading": "{{% heading \"whatsnext\" %}}",
      "source_file": "concepts_extend-kubernetes_operator.md",
      "content": "* Read the {{< glossary_tooltip text=\"CNCF\" term_id=\"cncf\" >}}\n  [Operator White Paper](https://github.com/cncf/tag-app-delivery/blob/163962c4b1cd70d085107fc579e3e04c2e14d59c/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md).\n* Learn more about [Custom Resources](/docs/concepts/extend-kubernetes/api-extension/custom-resources/)\n* Find ready-made operators on [OperatorHub.io](https://operatorhub.io/) to suit your use case\n* [Publish](https://operatorhub.io/) your operator for other people to use\n* Read [CoreOS' original article](https://web.archive.org/web/20170129131616/https://coreos.com/blog/introducing-operators.html)\n  that introduced the operator pattern (this is an archived version of the original article).\n* Read an [article](https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps)\n  from Google Cloud about best practices for building operators",
      "terms": [
        {
          "term": "CNCF",
          "tier": 1,
          "reasoning": "Cloud Native Computing Foundation - a specific organization and proper noun in the cloud-native ecosystem"
        },
        {
          "term": "Operator",
          "tier": 1,
          "reasoning": "A Kubernetes-specific pattern and resource type for managing applications"
        },
        {
          "term": "operator",
          "tier": 1,
          "reasoning": "Appears in lowercase form throughout the text referring to the Kubernetes operator pattern"
        },
        {
          "term": "operators",
          "tier": 1,
          "reasoning": "Plural form of the Kubernetes operator resource/pattern"
        },
        {
          "term": "Custom Resources",
          "tier": 1,
          "reasoning": "A specific Kubernetes API extension mechanism for defining custom API objects"
        },
        {
          "term": "OperatorHub.io",
          "tier": 1,
          "reasoning": "A specific platform/registry for discovering and publishing Kubernetes operators"
        },
        {
          "term": "CoreOS",
          "tier": 1,
          "reasoning": "A specific company/project that originally introduced the operator pattern"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the core subject of this documentation"
        },
        {
          "term": "operator pattern",
          "tier": 2,
          "reasoning": "A specific architectural pattern in Kubernetes for automating application management"
        },
        {
          "term": "stateful apps",
          "tier": 2,
          "reasoning": "A category of applications that maintain persistent state, relevant to operator use cases"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Fundamental compute abstraction in Kubernetes and cloud-native computing"
        },
        {
          "term": "White Paper",
          "tier": 3,
          "reasoning": "Technical document type referenced for operator specifications"
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "Application Programming Interface - referenced in context of Kubernetes API extension"
        },
        {
          "term": "best practices",
          "tier": 3,
          "reasoning": "Technical guidance term used in context of building operators"
        },
        {
          "term": "Google Cloud",
          "tier": 1,
          "reasoning": "A specific cloud provider platform mentioned as source of operator guidance"
        },
        {
          "term": "use case",
          "tier": 3,
          "reasoning": "Technical term describing specific application scenarios for operators"
        }
      ],
      "term_count": 16,
      "generated_at": "2026-02-08T17:48:51.453774",
      "elapsed_time": 9.34868836402893
    },
    {
      "chunk_id": "reference_glossary_sysctl_sec0",
      "doc_id": "reference_glossary_sysctl",
      "heading": "Introduction",
      "source_file": "reference_glossary_sysctl.md",
      "content": "---\ntitle: sysctl\nid: sysctl\ndate: 2019-02-12\nfull_link: /docs/tasks/administer-cluster/sysctl-cluster/\nshort_description: >\n  An interface for getting and setting Unix kernel parameters\n\naka:\ntags:\n- tool\n---\n `sysctl` is a semi-standardized interface for reading or changing the\n attributes of the running Unix kernel.\n\n<!--more-->\n\nOn Unix-like systems, `sysctl` is both the name of the tool that administrators\nuse to view and modify these settings, and also the system call that the tool\nuses.\n\n{{< glossary_tooltip text=\"Container\" term_id=\"container\" >}} runtimes and\nnetwork plugins may rely on `sysctl` values being set a certain way.",
      "terms": [
        {
          "term": "sysctl",
          "tier": 1,
          "reasoning": "Named Unix tool and system call for kernel parameter management, the primary subject of this documentation."
        },
        {
          "term": "Unix kernel",
          "tier": 2,
          "reasoning": "Core operating system component whose parameters sysctl manages."
        },
        {
          "term": "kernel parameters",
          "tier": 2,
          "reasoning": "Technical concept referring to configurable settings of the Unix kernel."
        },
        {
          "term": "Unix kernel parameters",
          "tier": 2,
          "reasoning": "Compound term describing the specific settings that sysctl reads and modifies."
        },
        {
          "term": "Unix-like systems",
          "tier": 3,
          "reasoning": "Category of operating systems where sysctl operates."
        },
        {
          "term": "system call",
          "tier": 2,
          "reasoning": "Technical concept describing the programmatic interface sysctl uses to interact with the kernel."
        },
        {
          "term": "Container",
          "tier": 2,
          "reasoning": "Core Kubernetes/infrastructure concept; container runtimes depend on sysctl values."
        },
        {
          "term": "network plugins",
          "tier": 2,
          "reasoning": "Infrastructure components that handle networking and may depend on sysctl values."
        },
        {
          "term": "interface",
          "tier": 3,
          "reasoning": "Technical term describing sysctl's role as a standardized access method."
        },
        {
          "term": "attributes",
          "tier": 3,
          "reasoning": "Technical term referring to the kernel properties that can be viewed or modified."
        },
        {
          "term": "running",
          "tier": 3,
          "reasoning": "Technical context indicating the kernel is active/executing when sysctl operates on it."
        },
        {
          "term": "semi-standardized",
          "tier": 3,
          "reasoning": "Technical descriptor indicating sysctl's partial standardization across Unix systems."
        },
        {
          "term": "tool",
          "tier": 3,
          "reasoning": "Explicitly tagged category for sysctl in the metadata."
        }
      ],
      "term_count": 13,
      "generated_at": "2026-02-08T21:00:29.566942",
      "elapsed_time": 11.349516868591309
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1beta1_sec18",
      "doc_id": "reference_config-api_apiserver-config.v1beta1",
      "heading": "`TCPTransport`     {#apiserver-k8s-io-v1beta1-TCPTransport}",
      "source_file": "reference_config-api_apiserver-config.v1beta1.md",
      "content": "**Appears in:**\n\n- [Transport](#apiserver-k8s-io-v1beta1-Transport)\n\n\n<p>TCPTransport provides the information to connect to konnectivity server via TCP</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>url</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>URL is the location of the konnectivity server to connect to.\nAs an example it might be &quot;https://127.0.0.1:8131&quot;</p>\n</td>\n</tr>\n<tr><td><code>tlsConfig</code><br/>\n<a href=\"#apiserver-k8s-io-v1beta1-TLSConfig\"><code>TLSConfig</code></a>\n</td>\n<td>\n   <p>TLSConfig is the config needed to use TLS when connecting to konnectivity server</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "Transport",
          "tier": 1,
          "reasoning": "Kubernetes API object type referenced in the documentation for network transport configuration."
        },
        {
          "term": "TCPTransport",
          "tier": 1,
          "reasoning": "Specific Kubernetes API resource type that provides TCP connection configuration to konnectivity server."
        },
        {
          "term": "konnectivity server",
          "tier": 1,
          "reasoning": "Named Kubernetes infrastructure component for network connectivity between control plane and nodes."
        },
        {
          "term": "TLSConfig",
          "tier": 1,
          "reasoning": "Kubernetes API object type for TLS configuration settings."
        },
        {
          "term": "apiserver-k8s-io-v1beta1-Transport",
          "tier": 1,
          "reasoning": "Specific API version and group reference for the Transport resource."
        },
        {
          "term": "apiserver-k8s-io-v1beta1-TLSConfig",
          "tier": 1,
          "reasoning": "Specific API version and group reference for the TLSConfig resource."
        },
        {
          "term": "TCP",
          "tier": 2,
          "reasoning": "Network protocol used for transport layer communication to konnectivity server."
        },
        {
          "term": "TLS",
          "tier": 2,
          "reasoning": "Transport Layer Security protocol for encrypted connections to konnectivity server."
        },
        {
          "term": "url",
          "tier": 3,
          "reasoning": "Configuration field specifying the location/address of the konnectivity server."
        },
        {
          "term": "tlsConfig",
          "tier": 2,
          "reasoning": "Configuration field name for TLS settings when connecting to konnectivity server."
        },
        {
          "term": "v1beta1",
          "tier": 2,
          "reasoning": "API version indicating beta maturity level of the Kubernetes API."
        },
        {
          "term": "https",
          "tier": 3,
          "reasoning": "Secure HTTP protocol shown in the example URL for konnectivity server connection."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term describing configuration parameters in the API object specification."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the url field in the API object."
        },
        {
          "term": "connect",
          "tier": 3,
          "reasoning": "Technical action describing establishing network connection to konnectivity server."
        }
      ],
      "term_count": 15,
      "generated_at": "2026-02-08T21:00:41.095446",
      "elapsed_time": 10.527211666107178
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec24",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`UserValidationRule`     {#apiserver-config-k8s-io-v1-UserValidationRule}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [JWTAuthenticator](#apiserver-config-k8s-io-v1-JWTAuthenticator)\n\n\n<p>UserValidationRule provides the configuration for a single user info validation rule.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>expression</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>expression represents the expression which will be evaluated by CEL.\nMust return true for the validation to pass.</p>\n<p>CEL expressions have access to the contents of UserInfo, organized into CEL variable:</p>\n<ul>\n<li>'user' - authentication.k8s.io/v1, Kind=UserInfo object\nRefer to https://github.com/kubernetes/api/blob/release-1.28/authentication/v1/types.go#L105-L122 for the definition.\nAPI documentation: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#userinfo-v1-authentication-k8s-io</li>\n</ul>\n<p>Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/</p>\n</td>\n</tr>\n<tr><td><code>message</code><br/>\n<code>string</code>\n</td>\n<td>\n   <p>message customizes the returned error message when rule returns false.\nmessage is a literal string.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "JWTAuthenticator",
          "tier": 1,
          "reasoning": "Named Kubernetes API object for JWT-based authentication configuration."
        },
        {
          "term": "UserValidationRule",
          "tier": 1,
          "reasoning": "Named configuration object that defines user info validation rules."
        },
        {
          "term": "UserInfo",
          "tier": 1,
          "reasoning": "Named Kubernetes API object (authentication.k8s.io/v1) containing user identity information."
        },
        {
          "term": "CEL",
          "tier": 2,
          "reasoning": "Common Expression Language - a domain-specific language used for validation expressions in Kubernetes."
        },
        {
          "term": "expression",
          "tier": 2,
          "reasoning": "Technical field name representing the CEL expression to be evaluated for validation."
        },
        {
          "term": "validation",
          "tier": 2,
          "reasoning": "Domain concept referring to the process of verifying user information meets specified rules."
        },
        {
          "term": "authentication",
          "tier": 2,
          "reasoning": "Security domain concept for verifying user identity, referenced in API group path."
        },
        {
          "term": "authentication.k8s.io/v1",
          "tier": 1,
          "reasoning": "Kubernetes API group and version for authentication-related resources."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "Application Programming Interface - general technical term used in context of Kubernetes API."
        },
        {
          "term": "CEL variable",
          "tier": 2,
          "reasoning": "Technical concept referring to variables accessible within CEL expressions."
        },
        {
          "term": "CEL expressions",
          "tier": 2,
          "reasoning": "Technical term for expressions written in Common Expression Language for validation logic."
        },
        {
          "term": "user",
          "tier": 2,
          "reasoning": "CEL variable name providing access to UserInfo object in validation expressions."
        },
        {
          "term": "message",
          "tier": 2,
          "reasoning": "Configuration field for customizing error messages when validation rules fail."
        },
        {
          "term": "error message",
          "tier": 3,
          "reasoning": "Technical term for the message returned when validation fails."
        },
        {
          "term": "literal string",
          "tier": 3,
          "reasoning": "Technical term describing the type of value expected for the message field."
        },
        {
          "term": "rule",
          "tier": 2,
          "reasoning": "Domain concept referring to a single validation condition to be evaluated."
        },
        {
          "term": "Kind",
          "tier": 2,
          "reasoning": "Kubernetes API concept identifying the type of resource object."
        },
        {
          "term": "object",
          "tier": 3,
          "reasoning": "Technical term referring to Kubernetes API resource instances."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for configuration fields."
        },
        {
          "term": "Field",
          "tier": 2,
          "reasoning": "Technical term for configuration parameters in Kubernetes API objects."
        },
        {
          "term": "kubernetes-api",
          "tier": 1,
          "reasoning": "Reference to the Kubernetes API documentation and specification."
        },
        {
          "term": "release-1.28",
          "tier": 2,
          "reasoning": "Kubernetes version reference indicating API compatibility."
        },
        {
          "term": "v1.28",
          "tier": 2,
          "reasoning": "Kubernetes version identifier referenced in documentation links."
        }
      ],
      "term_count": 23,
      "generated_at": "2026-02-08T21:00:55.900069",
      "elapsed_time": 13.80327320098877
    },
    {
      "chunk_id": "reference_access-authn-authz_validating-admission-policy_sec0",
      "doc_id": "reference_access-authn-authz_validating-admission-policy",
      "heading": "Introduction",
      "source_file": "reference_access-authn-authz_validating-admission-policy.md",
      "content": "---\nreviewers:\n- liggitt\n- jpbetz\n- cici37\ntitle: Validating Admission Policy\ncontent_type: concept\n---\n\n<!-- overview -->\n\n{{< feature-state state=\"stable\" for_k8s_version=\"v1.30\" >}}\n\nThis page provides an overview of Validating Admission Policy.\n\n\n<!-- body -->",
      "terms": [
        {
          "term": "Validating Admission Policy",
          "tier": 1,
          "reasoning": "Core Kubernetes API resource and the primary subject of this documentation page."
        },
        {
          "term": "Admission Policy",
          "tier": 2,
          "reasoning": "Domain concept referring to policies that control admission of resources to the cluster."
        },
        {
          "term": "stable",
          "tier": 3,
          "reasoning": "Feature lifecycle stage indicating the feature has reached production-ready status in Kubernetes."
        },
        {
          "term": "v1.30",
          "tier": 3,
          "reasoning": "Specific Kubernetes version identifier indicating when the feature became stable."
        },
        {
          "term": "feature-state",
          "tier": 3,
          "reasoning": "Kubernetes documentation concept indicating the maturity level of a feature."
        },
        {
          "term": "admission",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to the process of validating and mutating API requests before persistence."
        }
      ],
      "term_count": 6,
      "generated_at": "2026-02-08T21:01:01.809018",
      "elapsed_time": 4.907103776931763
    },
    {
      "chunk_id": "concepts_workloads_management_sec0",
      "doc_id": "concepts_workloads_management",
      "heading": "Introduction",
      "source_file": "concepts_workloads_management.md",
      "content": "---\ntitle: Managing Workloads\ncontent_type: concept\nreviewers:\n- janetkuo\nweight: 40\n---\n\n<!-- overview -->\n\nYou've deployed your application and exposed it via a Service. Now what? Kubernetes provides a\nnumber of tools to help you manage your application deployment, including scaling and updating.\n\n<!-- body -->",
      "terms": [
        {
          "term": "Workloads",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to applications running on the cluster, appears in title as domain-specific term"
        },
        {
          "term": "application",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context referring to containerized software deployed on the cluster"
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource used to expose applications, capitalized indicating proper noun"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The primary platform/system being documented, core proper noun"
        },
        {
          "term": "application deployment",
          "tier": 2,
          "reasoning": "Domain concept describing the process of running applications on Kubernetes"
        },
        {
          "term": "scaling",
          "tier": 2,
          "reasoning": "Key Kubernetes operational concept for adjusting application capacity"
        },
        {
          "term": "updating",
          "tier": 2,
          "reasoning": "Technical process in Kubernetes for modifying deployed applications"
        },
        {
          "term": "deployed",
          "tier": 2,
          "reasoning": "Technical verb describing the state of an application running on Kubernetes"
        },
        {
          "term": "exposed",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context meaning making an application accessible via networking"
        },
        {
          "term": "manage",
          "tier": 3,
          "reasoning": "Technical verb in context of Kubernetes workload management operations"
        }
      ],
      "term_count": 10,
      "generated_at": "2026-02-08T21:01:11.179568",
      "elapsed_time": 8.368712663650513
    },
    {
      "chunk_id": "tasks_manage-kubernetes-objects_declarative-config_sec6",
      "doc_id": "tasks_manage-kubernetes-objects_declarative-config",
      "heading": "How apply calculates differences and merges changes",
      "source_file": "tasks_manage-kubernetes-objects_declarative-config.md",
      "content": "{{< caution >}}\nA *patch* is an update operation that is scoped to specific fields of an object\ninstead of the entire object. This enables updating only a specific set of fields\non an object without reading the object first.\n{{< /caution >}}\n\nWhen `kubectl apply` updates the live configuration for an object,\nit does so by sending a patch request to the API server. The\npatch defines updates scoped to specific fields of the live object\nconfiguration. The `kubectl apply` command calculates this patch request\nusing the configuration file, the live configuration, and the\n`last-applied-configuration` annotation stored in the live configuration.\n\n### Merge patch calculation\n\nThe `kubectl apply` command writes the contents of the configuration file to the\n`kubectl.kubernetes.io/last-applied-configuration` annotation. This\nis used to identify fields that have been removed from the configuration\nfile and need to be cleared from the live configuration. Here are the steps used\nto calculate which fields should be deleted or set:\n\n1. Calculate the fields to delete. These are the fields present in\n   `last-applied-configuration` and missing from the configuration file.\n2. Calculate the fields to add or set. These are the fields present in\n   the configuration file whose values don't match the live configuration.\n\nHere's an example. Suppose this is the configuration file for a Deployment object:\n\n{{% code_sample file=\"application/update_deployment.yaml\" %}}\n\nAlso, suppose this is the live configuration for the same Deployment object:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    # ...\n    # note that the annotation does not contain replicas\n    # because it was not updated through apply\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\n      \"metadata\":{\"annotations\":{},\"name\":\"nginx-deployment\",\"namespace\":\"default\"},\n      \"spec\":{\"minReadySeconds\":5,\"selector\":{\"matchLabels\":{\"app\":nginx}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"nginx\"}},\n      \"spec\":{\"containers\":[{\"image\":\"nginx:1.14.2\",\"name\":\"nginx\",\n      \"ports\":[{\"containerPort\":80}]}]}}}}\n  # ...\nspec:\n  replicas: 2 # written by scale\n  # ...\n  minReadySeconds: 5\n  selector:\n    matchLabels:\n      # ...\n      app: nginx\n  template:\n    metadata:\n      # ...\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx:1.14.2\n        # ...\n        name: nginx\n        ports:\n        - containerPort: 80\n      # ...\n```\n\nHere are the merge calculations that would be performed by `kubectl apply`:\n\n1. Calculate the fields to delete by reading values from\n   `last-applied-configuration` and comparing them to values in the\n   configuration file.\n   Clear fields explicitly set to null in the local object configuration file\n   regardless of whether they appear in the `last-applied-configuration`.\n   In this example, `minReadySeconds` appears in the\n   `last-applied-configuration` annotation, but does not appear in the configuration file.\n   **Action:** Clear `minReadySeconds` from the live configuration.\n2. Calculate the fields to set by reading values from the configuration\n   file and comparing them to values in the live configuration. In this example,\n   the value of `image` in the configuration file does not match\n   the value in the live configuration. **Action:** Set the value of `image` in the live configuration.\n3. Set the `last-applied-configuration` annotation to match the value\n   of the configuration file.\n4. Merge the results from 1, 2, 3 into a single patch request to the API server.\n\nHere is the live configuration that is the result of the merge:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    # ...\n    # The annotation contains the updated image to nginx 1.16.1,\n    # but does not contain the updated replicas to 2\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\n      \"metadata\":{\"annotations\":{},\"name\":\"nginx-deployment\",\"namespace\":\"default\"},\n      \"spec\":{\"selector\":{\"matchLabels\":{\"app\":nginx}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"nginx\"}},\n      \"spec\":{\"containers\":[{\"image\":\"nginx:1.16.1\",\"name\":\"nginx\",\n      \"ports\":[{\"containerPort\":80}]}]}}}}\n    # ...\nspec:\n  selector:\n    matchLabels:\n      # ...\n      app: nginx\n  replicas: 2 # Set by `kubectl scale`.  Ignored by `kubectl apply`.\n  # minReadySeconds cleared by `kubectl apply`\n  # ...\n  template:\n    metadata:\n      # ...\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx:1.16.1 # Set by `kubectl apply`\n        # ...\n        name: nginx\n        ports:\n        - containerPort: 80\n        # ...\n      # ...\n    # ...\n  # ...\n```\n\n### How different types of fields are merged\n\nHow a particular field in a configuration file is merged with\nthe live configuration depends on the\ntype of the field. There are several types of fields:\n\n- *primitive*: A field of type string, integer, or boolean.\n  For example, `image` and `replicas` are primitive fields. **Action:** Replace.\n\n- *map*, also called *object*: A field of type map or a complex type that contains subfields. For example, `labels`,\n  `annotations`,`spec` and `metadata` are all maps. **Action:** Merge elements or subfields.\n\n- *list*: A field containing a list of items that can be either primitive types or maps.\n  For example, `containers`, `ports`, and `args` are lists. **Action:** Varies.\n\nWhen `kubectl apply` updates a map or list field, it typically does\nnot replace the entire field, but instead updates the individual subelements.\nFor instance, when merging the `spec` on a Deployment, the entire `spec` is\nnot replaced. Instead the subfields of `spec`, such as `replicas`, are compared\nand merged.\n\n### Merging changes to primitive fields\n\nPrimitive fields are replaced or cleared.\n\n{{< note >}}\n`-` is used for \"not applicable\" because the value is not used.\n{{< /note >}}\n\n| Field in object configuration file  | Field in live object configuration | Field in last-applied-configuration | Action                                    |\n|-------------------------------------|------------------------------------|-------------------------------------|-------------------------------------------|\n| Yes                                 | Yes                                | -                                   | Set live to configuration file value.  |\n| Yes                                 | No                                 | -                                   | Set live to local configuration.           |\n| No                                  | -                                  | Yes                                 | Clear from live configuration.            |\n| No                                  | -                                  | No                                  | Do nothing. Keep live value.             |\n\n### Merging changes to map fields\n\nFields that represent maps are merged by comparing each of the subfields or elements of the map:\n\n{{< note >}}\n`-` is used for \"not applicable\" because the value is not used.\n{{< /note >}}\n\n| Key in object configuration file    | Key in live object configuration   | Field in last-applied-configuration | Action                           |\n|-------------------------------------|------------------------------------|-------------------------------------|----------------------------------|\n| Yes                                 | Yes                                | -                                   | Compare sub fields values.        |\n| Yes                                 | No                                 | -                                   | Set live to local configuration.  |\n| No                                  | -                                  | Yes                                 | Delete from live configuration.   |\n| No                                  | -                                  | No                                  | Do nothing. Keep live value.     |\n\n### Merging changes for fields of type list\n\nMerging changes to a list uses one of three strategies:\n\n* Replace the list if all its elements are primitives.\n* Merge individual elements in a list of complex elements.\n* Merge a list of primitive elements.\n\nThe choice of strategy is made on a per-field basis.\n\n#### Replace the list if all its elements are primitives\n\nTreat the list the same as a primitive field. Replace or delete the\nentire list. This preserves ordering.\n\n**Example:** Use `kubectl apply` to update the `args` field of a Container in a Pod. This sets\nthe value of `args` in the live configuration to the value in the configuration file.\nAny `args` elements that had previously been added to the live configuration are lost.\nThe order of the `args` elements defined in the configuration file is\nretained in the live configuration.\n\n```yaml",
      "terms": [
        {
          "term": "patch",
          "tier": 2,
          "reasoning": "Core technical concept describing an update operation scoped to specific fields of an object"
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Specific kubectl command for applying configuration changes to Kubernetes objects"
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Primary Kubernetes CLI tool for interacting with clusters"
        },
        {
          "term": "live configuration",
          "tier": 2,
          "reasoning": "Domain concept referring to the current state of an object in the cluster"
        },
        {
          "term": "API server",
          "tier": 1,
          "reasoning": "Core Kubernetes component that receives patch requests"
        },
        {
          "term": "patch request",
          "tier": 2,
          "reasoning": "Technical concept for the request type sent to update specific fields"
        },
        {
          "term": "configuration file",
          "tier": 2,
          "reasoning": "Domain concept for the local file containing desired object state"
        },
        {
          "term": "last-applied-configuration",
          "tier": 1,
          "reasoning": "Specific Kubernetes annotation used to track previously applied configuration"
        },
        {
          "term": "annotation",
          "tier": 2,
          "reasoning": "Kubernetes metadata concept for attaching non-identifying information to objects"
        },
        {
          "term": "Merge patch calculation",
          "tier": 2,
          "reasoning": "Technical process describing how kubectl apply computes changes"
        },
        {
          "term": "kubectl.kubernetes.io/last-applied-configuration",
          "tier": 1,
          "reasoning": "Full annotation key name used by kubectl apply for tracking configuration"
        },
        {
          "term": "Deployment",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource type for managing application deployments"
        },
        {
          "term": "apiVersion",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the API version for the resource"
        },
        {
          "term": "apps/v1",
          "tier": 1,
          "reasoning": "Specific Kubernetes API group and version for apps resources"
        },
        {
          "term": "kind",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the type of resource"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Kubernetes object section containing identifying information"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes object section containing the desired state specification"
        },
        {
          "term": "replicas",
          "tier": 2,
          "reasoning": "Deployment field specifying the number of pod instances"
        },
        {
          "term": "minReadySeconds",
          "tier": 2,
          "reasoning": "Deployment spec field controlling minimum ready time before considering pod available"
        },
        {
          "term": "selector",
          "tier": 2,
          "reasoning": "Kubernetes field for matching pods to controllers via labels"
        },
        {
          "term": "matchLabels",
          "tier": 2,
          "reasoning": "Selector field for exact label matching"
        },
        {
          "term": "template",
          "tier": 2,
          "reasoning": "Pod template specification within a Deployment"
        },
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Kubernetes metadata for identifying and selecting objects"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Pod spec field listing container definitions"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container spec field specifying the container image to run"
        },
        {
          "term": "nginx",
          "tier": 1,
          "reasoning": "Specific container image/application name used in the example"
        },
        {
          "term": "nginx:1.14.2",
          "tier": 1,
          "reasoning": "Specific container image tag referenced in the example"
        },
        {
          "term": "nginx:1.16.1",
          "tier": 1,
          "reasoning": "Specific container image tag referenced in the merge result"
        },
        {
          "term": "ports",
          "tier": 2,
          "reasoning": "Container spec field for exposing container ports"
        },
        {
          "term": "containerPort",
          "tier": 2,
          "reasoning": "Port specification field for container network ports"
        },
        {
          "term": "name",
          "tier": 2,
          "reasoning": "Kubernetes metadata field for object identification"
        },
        {
          "term": "namespace",
          "tier": 2,
          "reasoning": "Kubernetes concept for logical resource isolation"
        },
        {
          "term": "default",
          "tier": 2,
          "reasoning": "Default Kubernetes namespace name"
        },
        {
          "term": "scale",
          "tier": 2,
          "reasoning": "Kubernetes operation for adjusting replica count"
        },
        {
          "term": "object",
          "tier": 2,
          "reasoning": "General Kubernetes term for API resources/entities"
        },
        {
          "term": "fields",
          "tier": 2,
          "reasoning": "Technical term for specific properties within Kubernetes objects"
        },
        {
          "term": "null",
          "tier": 3,
          "reasoning": "Technical value used to explicitly clear fields in configuration"
        }
      ],
      "term_count": 37,
      "generated_at": "2026-02-08T21:01:32.790316",
      "elapsed_time": 20.609029054641724
    },
    {
      "chunk_id": "tasks_administer-cluster_topology-manager_sec3",
      "doc_id": "tasks_administer-cluster_topology-manager",
      "heading": "Topology manager scopes and policies",
      "source_file": "tasks_administer-cluster_topology-manager.md",
      "content": "The Topology Manager currently:\n\n- aligns Pods of all QoS classes.\n- aligns the requested resources that Hint Provider provides topology hints for.\n\nIf these conditions are met, the Topology Manager will align the requested resources.\n\nIn order to customize how this alignment is carried out, the Topology Manager provides two\ndistinct options: `scope` and `policy`.\n\nThe `scope` defines the granularity at which you would like resource alignment to be performed,\nfor example, at the `pod` or `container` level. And the `policy` defines the actual policy used to\ncarry out the alignment, for example, `best-effort`, `restricted`, and `single-numa-node`.\nDetails on the various `scopes` and `policies` available today can be found below.\n\n{{< note >}}\nTo align CPU resources with other requested resources in a Pod spec, the CPU Manager should be\nenabled and proper CPU Manager policy should be configured on a Node.\nSee [Control CPU Management Policies on the Node](/docs/tasks/administer-cluster/cpu-management-policies/).\n{{< /note >}}\n\n{{< note >}}\nTo align memory (and hugepages) resources with other requested resources in a Pod spec, the Memory\nManager should be enabled and proper Memory Manager policy should be configured on a Node. Refer to\n[Memory Manager](/docs/tasks/administer-cluster/memory-manager/) documentation.\n{{< /note >}}",
      "terms": [
        {
          "term": "Topology Manager",
          "tier": 1,
          "reasoning": "Core Kubernetes component responsible for resource alignment across NUMA nodes."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object and workload unit."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Singular form of the core Kubernetes workload resource."
        },
        {
          "term": "QoS classes",
          "tier": 2,
          "reasoning": "Quality of Service classification system for Kubernetes Pods."
        },
        {
          "term": "Hint Provider",
          "tier": 1,
          "reasoning": "Named component that provides topology hints for resource alignment."
        },
        {
          "term": "topology hints",
          "tier": 2,
          "reasoning": "Domain concept describing hints used for NUMA-aware resource placement."
        },
        {
          "term": "scope",
          "tier": 2,
          "reasoning": "Configuration option defining granularity of resource alignment."
        },
        {
          "term": "policy",
          "tier": 2,
          "reasoning": "Configuration option defining the alignment strategy used by Topology Manager."
        },
        {
          "term": "resource alignment",
          "tier": 2,
          "reasoning": "Technical process of aligning resources across topology domains."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Core domain concept representing the unit of execution within a Pod."
        },
        {
          "term": "best-effort",
          "tier": 2,
          "reasoning": "Named Topology Manager policy option for alignment strategy."
        },
        {
          "term": "restricted",
          "tier": 2,
          "reasoning": "Named Topology Manager policy option for stricter alignment."
        },
        {
          "term": "single-numa-node",
          "tier": 2,
          "reasoning": "Named Topology Manager policy requiring all resources from one NUMA node."
        },
        {
          "term": "CPU resources",
          "tier": 2,
          "reasoning": "Technical term for compute resources managed by CPU Manager."
        },
        {
          "term": "CPU Manager",
          "tier": 1,
          "reasoning": "Kubernetes component that manages CPU allocation policies on nodes."
        },
        {
          "term": "CPU Manager policy",
          "tier": 2,
          "reasoning": "Configuration setting for CPU Manager behavior."
        },
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a worker machine in the cluster."
        },
        {
          "term": "CPU Management Policies",
          "tier": 2,
          "reasoning": "Domain concept for policies controlling CPU allocation on nodes."
        },
        {
          "term": "memory",
          "tier": 3,
          "reasoning": "System resource type managed for NUMA-aware allocation."
        },
        {
          "term": "hugepages",
          "tier": 2,
          "reasoning": "Linux memory feature for large memory pages, managed by Memory Manager."
        },
        {
          "term": "Memory Manager",
          "tier": 1,
          "reasoning": "Kubernetes component that manages memory allocation policies."
        },
        {
          "term": "Memory Manager policy",
          "tier": 2,
          "reasoning": "Configuration setting for Memory Manager behavior."
        },
        {
          "term": "Pod spec",
          "tier": 2,
          "reasoning": "Technical term for the specification section of a Pod definition."
        },
        {
          "term": "requested resources",
          "tier": 2,
          "reasoning": "Domain concept for resources explicitly requested in Pod specifications."
        },
        {
          "term": "scopes",
          "tier": 2,
          "reasoning": "Plural form referring to available Topology Manager scope options."
        },
        {
          "term": "policies",
          "tier": 2,
          "reasoning": "Plural form referring to available Topology Manager policy options."
        },
        {
          "term": "pod",
          "tier": 2,
          "reasoning": "Scope option value for pod-level resource alignment."
        },
        {
          "term": "NUMA",
          "tier": 3,
          "reasoning": "Non-Uniform Memory Access architecture concept implicit in single-numa-node policy."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Implicit domain concept as context for node administration."
        }
      ],
      "term_count": 29,
      "generated_at": "2026-02-08T21:01:48.544507",
      "elapsed_time": 14.7516770362854
    },
    {
      "chunk_id": "concepts_services-networking_ingress_sec1",
      "doc_id": "concepts_services-networking_ingress",
      "heading": "Terminology",
      "source_file": "concepts_services-networking_ingress.md",
      "content": "For clarity, this guide defines the following terms:\n\n* Node: A worker machine in Kubernetes, part of a cluster.\n* Cluster: A set of Nodes that run containerized applications managed by Kubernetes.\n  For this example, and in most common Kubernetes deployments, nodes in the cluster\n  are not part of the public internet.\n* Edge router: A router that enforces the firewall policy for your cluster. This\n  could be a gateway managed by a cloud provider or a physical piece of hardware.\n* Cluster network: A set of links, logical or physical, that facilitate communication\n  within a cluster according to the Kubernetes [networking model](/docs/concepts/cluster-administration/networking/).\n* Service: A Kubernetes {{< glossary_tooltip term_id=\"service\" >}} that identifies\n  a set of Pods using {{< glossary_tooltip text=\"label\" term_id=\"label\" >}} selectors.\n  Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network.",
      "terms": [
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Core Kubernetes resource representing a worker machine in the cluster."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The primary container orchestration platform being documented."
        },
        {
          "term": "Cluster",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes architectural concept representing a set of nodes."
        },
        {
          "term": "containerized applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications packaged in containers."
        },
        {
          "term": "Edge router",
          "tier": 2,
          "reasoning": "Network infrastructure component that enforces firewall policy at cluster boundary."
        },
        {
          "term": "router",
          "tier": 3,
          "reasoning": "General networking term with specific meaning in cluster context."
        },
        {
          "term": "firewall policy",
          "tier": 2,
          "reasoning": "Security concept governing network traffic rules for the cluster."
        },
        {
          "term": "gateway",
          "tier": 2,
          "reasoning": "Network component that can serve as edge router, managed by cloud provider."
        },
        {
          "term": "cloud provider",
          "tier": 2,
          "reasoning": "Infrastructure concept referring to managed cloud services hosting Kubernetes."
        },
        {
          "term": "Cluster network",
          "tier": 2,
          "reasoning": "Kubernetes networking concept describing internal cluster communication infrastructure."
        },
        {
          "term": "networking model",
          "tier": 2,
          "reasoning": "Kubernetes architectural concept defining how network communication works."
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Core Kubernetes API object that identifies and exposes a set of Pods."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Core Kubernetes resource representing the smallest deployable unit."
        },
        {
          "term": "label",
          "tier": 2,
          "reasoning": "Kubernetes concept for key-value pairs used to organize and select resources."
        },
        {
          "term": "selectors",
          "tier": 2,
          "reasoning": "Kubernetes mechanism for identifying resources based on labels."
        },
        {
          "term": "virtual IPs",
          "tier": 2,
          "reasoning": "Networking concept for IP addresses assigned to Services for internal routing."
        },
        {
          "term": "worker machine",
          "tier": 2,
          "reasoning": "Infrastructure term describing the role of a Node in the cluster."
        },
        {
          "term": "Nodes",
          "tier": 1,
          "reasoning": "Plural form of Node, core Kubernetes resource appearing in cluster definition."
        },
        {
          "term": "public internet",
          "tier": 3,
          "reasoning": "Networking context term distinguishing cluster-internal from external networks."
        },
        {
          "term": "hardware",
          "tier": 3,
          "reasoning": "Infrastructure term referring to physical edge router implementation."
        },
        {
          "term": "links",
          "tier": 3,
          "reasoning": "Networking term describing connections in cluster network."
        },
        {
          "term": "communication",
          "tier": 3,
          "reasoning": "Technical term describing data exchange within cluster network context."
        },
        {
          "term": "routable",
          "tier": 3,
          "reasoning": "Networking term describing accessibility of virtual IPs within cluster."
        }
      ],
      "term_count": 23,
      "generated_at": "2026-02-08T21:02:01.952858",
      "elapsed_time": 12.405556917190552
    },
    {
      "chunk_id": "tasks_configure-pod-container_configure-pod-configmap_sec19",
      "doc_id": "tasks_configure-pod-container_configure-pod-configmap",
      "heading": "You might already have removed the next set",
      "source_file": "tasks_configure-pod-container_configure-pod-configmap.md",
      "content": "kubectl delete configmaps/special-config configmaps/env-config\nkubectl delete configmap -l 'game-config in (config-4,config-5)'\n```\n\nRemove the `kustomization.yaml` file that you used to generate the ConfigMap:\n\n```bash\nrm kustomization.yaml\n```\n\nIf you created a directory `configure-pod-container` and no longer need it, you should remove that too,\nor move it into the trash can / deleted files location.\n\n```bash\nrm -r configure-pod-container\n```",
      "terms": [
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Primary Kubernetes CLI tool used for cluster management and resource manipulation."
        },
        {
          "term": "configmaps",
          "tier": 1,
          "reasoning": "Kubernetes API object for storing non-confidential configuration data as key-value pairs."
        },
        {
          "term": "ConfigMap",
          "tier": 1,
          "reasoning": "Kubernetes API resource referenced in the context of generation and deletion."
        },
        {
          "term": "special-config",
          "tier": 1,
          "reasoning": "Named ConfigMap resource being deleted in the example command."
        },
        {
          "term": "env-config",
          "tier": 1,
          "reasoning": "Named ConfigMap resource being deleted in the example command."
        },
        {
          "term": "config-4",
          "tier": 1,
          "reasoning": "Named configuration resource referenced in label selector."
        },
        {
          "term": "config-5",
          "tier": 1,
          "reasoning": "Named configuration resource referenced in label selector."
        },
        {
          "term": "game-config",
          "tier": 1,
          "reasoning": "Label key used for selecting ConfigMap resources."
        },
        {
          "term": "kustomization.yaml",
          "tier": 1,
          "reasoning": "Kustomize configuration file used to generate Kubernetes resources."
        },
        {
          "term": "configure-pod-container",
          "tier": 2,
          "reasoning": "Directory name related to pod and container configuration workflow."
        },
        {
          "term": "delete",
          "tier": 2,
          "reasoning": "Kubernetes kubectl subcommand for removing resources from the cluster."
        },
        {
          "term": "kubectl delete",
          "tier": 2,
          "reasoning": "Complete command for deleting Kubernetes resources."
        },
        {
          "term": "-l",
          "tier": 3,
          "reasoning": "kubectl flag for label selector used to filter resources."
        },
        {
          "term": "rm",
          "tier": 3,
          "reasoning": "Unix/Linux command for removing files, used in cleanup context."
        },
        {
          "term": "rm -r",
          "tier": 3,
          "reasoning": "Unix/Linux command for recursive directory removal."
        },
        {
          "term": "bash",
          "tier": 3,
          "reasoning": "Shell environment specified for executing the cleanup commands."
        },
        {
          "term": "directory",
          "tier": 3,
          "reasoning": "File system concept relevant to the cleanup procedure."
        },
        {
          "term": "pod",
          "tier": 1,
          "reasoning": "Core Kubernetes workload resource referenced in directory name 'configure-pod-container'."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept referenced in directory name 'configure-pod-container'."
        }
      ],
      "term_count": 19,
      "generated_at": "2026-02-08T21:02:13.685475",
      "elapsed_time": 10.729471683502197
    },
    {
      "chunk_id": "reference_node_node-status_sec6",
      "doc_id": "reference_node_node-status",
      "heading": "Declared features {#declaredfeatures}",
      "source_file": "reference_node_node-status.md",
      "content": "{{< feature-state feature_gate_name=\"NodeDeclaredFeatures\" >}}\n\nThis field lists specific Kubernetes features that are currently enabled on the\nnode's kubelet via [feature gates](/docs/reference/command-line-tools-reference/feature-gates/).\nThe features are reported by the kubelet as a list of strings in the\n`.status.declaredFeatures` field of the Node object.\n\nThis field is intended for newer features under active development; features that\nhave graduated and no longer require a feature gate are considered baseline and\nare not declared in this field. This reflects the enablement of Kubernetes\nfeatures, not the underlying operating system or kernel capabilities of the node.\n\nSee [Node Declared Features](/docs/concepts/scheduling-eviction/node-declared-features/)\nfor more details.",
      "terms": [
        {
          "term": "NodeDeclaredFeatures",
          "tier": 1,
          "reasoning": "Specific Kubernetes feature gate name that controls node feature declaration functionality."
        },
        {
          "term": "feature_gate_name",
          "tier": 2,
          "reasoning": "Technical parameter reference for feature gate configuration in Kubernetes."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform this documentation describes."
        },
        {
          "term": "kubelet",
          "tier": 1,
          "reasoning": "Core Kubernetes node agent component that reports features."
        },
        {
          "term": "feature gates",
          "tier": 2,
          "reasoning": "Kubernetes mechanism for enabling/disabling experimental or optional features."
        },
        {
          "term": "node",
          "tier": 2,
          "reasoning": "Kubernetes worker machine concept where kubelet runs and features are reported."
        },
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a worker machine in the cluster."
        },
        {
          "term": ".status.declaredFeatures",
          "tier": 1,
          "reasoning": "Specific API field path in the Node object where features are reported."
        },
        {
          "term": "Node object",
          "tier": 1,
          "reasoning": "The Kubernetes API resource representing a node in the cluster."
        },
        {
          "term": "features",
          "tier": 2,
          "reasoning": "Technical concept referring to Kubernetes capabilities that can be enabled/disabled."
        },
        {
          "term": "strings",
          "tier": 3,
          "reasoning": "Data type used to represent the list of declared features."
        },
        {
          "term": "field",
          "tier": 3,
          "reasoning": "Technical term for a property within a Kubernetes API object."
        },
        {
          "term": "operating system",
          "tier": 3,
          "reasoning": "System software concept distinguished from Kubernetes feature enablement."
        },
        {
          "term": "kernel",
          "tier": 3,
          "reasoning": "OS kernel capabilities explicitly distinguished from Kubernetes features."
        },
        {
          "term": "Node Declared Features",
          "tier": 1,
          "reasoning": "Named Kubernetes concept/feature for declaring node capabilities."
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Kubernetes process referenced in the documentation path for node declared features."
        },
        {
          "term": "eviction",
          "tier": 2,
          "reasoning": "Kubernetes concept referenced in the documentation path alongside scheduling."
        },
        {
          "term": "baseline",
          "tier": 2,
          "reasoning": "Technical term describing graduated features that no longer need feature gates."
        },
        {
          "term": "graduated",
          "tier": 2,
          "reasoning": "Feature lifecycle stage indicating a feature has become stable/baseline."
        },
        {
          "term": "enabled",
          "tier": 2,
          "reasoning": "Technical state describing whether a feature is active on a node."
        },
        {
          "term": "capabilities",
          "tier": 2,
          "reasoning": "Technical term for node abilities, distinguished between OS and Kubernetes levels."
        }
      ],
      "term_count": 21,
      "generated_at": "2026-02-08T21:02:28.001835",
      "elapsed_time": 13.313749074935913
    },
    {
      "chunk_id": "concepts_policy__index_sec3",
      "doc_id": "concepts_policy__index",
      "heading": "Apply policies using ValidatingAdmissionPolicy",
      "source_file": "concepts_policy__index.md",
      "content": "Validating admission policies allow configurable validation checks to be executed in the API server using the Common Expression Language (CEL). For example, a `ValidatingAdmissionPolicy` can be used to disallow use of the `latest` image tag.\n\nA `ValidatingAdmissionPolicy` operates on an API request and can be used to block, audit, and warn users about non-compliant configurations.\n\nDetails on the `ValidatingAdmissionPolicy` API, with examples, are documented in a dedicated section:\n* [Validating Admission Policy](/docs/reference/access-authn-authz/validating-admission-policy/)",
      "terms": [
        {
          "term": "ValidatingAdmissionPolicy",
          "tier": 1,
          "reasoning": "Core Kubernetes API object for configurable validation checks in the API server."
        },
        {
          "term": "Validating admission policies",
          "tier": 1,
          "reasoning": "Named Kubernetes feature for admission control validation."
        },
        {
          "term": "Validating Admission Policy",
          "tier": 1,
          "reasoning": "Proper noun reference to the Kubernetes API resource and documentation section."
        },
        {
          "term": "API server",
          "tier": 1,
          "reasoning": "Core Kubernetes control plane component that processes API requests."
        },
        {
          "term": "Common Expression Language",
          "tier": 2,
          "reasoning": "Domain-specific language used for writing validation expressions in Kubernetes."
        },
        {
          "term": "CEL",
          "tier": 3,
          "reasoning": "Acronym for Common Expression Language, a technical standard used in validation policies."
        },
        {
          "term": "API request",
          "tier": 2,
          "reasoning": "Technical concept referring to requests made to the Kubernetes API server."
        },
        {
          "term": "validation checks",
          "tier": 2,
          "reasoning": "Domain concept describing the verification process performed by admission policies."
        },
        {
          "term": "configurable validation",
          "tier": 2,
          "reasoning": "Technical concept describing customizable validation behavior."
        },
        {
          "term": "image tag",
          "tier": 2,
          "reasoning": "Container domain concept referring to version identifiers for container images."
        },
        {
          "term": "latest",
          "tier": 2,
          "reasoning": "Specific image tag value with special meaning in container ecosystems, often discouraged."
        },
        {
          "term": "block",
          "tier": 2,
          "reasoning": "Admission control action that prevents non-compliant configurations from being applied."
        },
        {
          "term": "audit",
          "tier": 2,
          "reasoning": "Admission control action that logs policy violations without blocking."
        },
        {
          "term": "warn",
          "tier": 2,
          "reasoning": "Admission control action that alerts users about non-compliant configurations."
        },
        {
          "term": "non-compliant configurations",
          "tier": 2,
          "reasoning": "Domain concept describing configurations that violate defined policies."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "General technical term for Application Programming Interface, contextually relevant to Kubernetes."
        },
        {
          "term": "admission",
          "tier": 2,
          "reasoning": "Kubernetes domain concept referring to the process of validating and mutating API requests."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:02:39.380749",
      "elapsed_time": 10.375048160552979
    },
    {
      "chunk_id": "concepts_policy__index_sec1",
      "doc_id": "concepts_policy__index",
      "heading": "Apply policies using API objects",
      "source_file": "concepts_policy__index.md",
      "content": "Some API objects act as policies. Here are some examples:\n* [NetworkPolicies](/docs/concepts/services-networking/network-policies/) can be used to restrict ingress and egress traffic for a workload.\n* [LimitRanges](/docs/concepts/policy/limit-range/) manage resource allocation constraints across different object kinds.\n* [ResourceQuotas](/docs/concepts/policy/resource-quotas/) limit resource consumption for a {{< glossary_tooltip text=\"namespace\" term_id=\"namespace\" >}}.",
      "terms": [
        {
          "term": "API objects",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to the persistent entities in the system that represent cluster state."
        },
        {
          "term": "policies",
          "tier": 2,
          "reasoning": "Domain concept describing API objects that enforce rules and constraints on cluster behavior."
        },
        {
          "term": "NetworkPolicies",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that controls network traffic flow for workloads."
        },
        {
          "term": "ingress",
          "tier": 2,
          "reasoning": "Networking concept referring to incoming traffic to a workload or cluster."
        },
        {
          "term": "egress",
          "tier": 2,
          "reasoning": "Networking concept referring to outgoing traffic from a workload or cluster."
        },
        {
          "term": "traffic",
          "tier": 3,
          "reasoning": "Technical networking term describing data flow in the context of network policies."
        },
        {
          "term": "workload",
          "tier": 2,
          "reasoning": "Kubernetes domain concept referring to applications running on the cluster."
        },
        {
          "term": "LimitRanges",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that manages resource allocation constraints."
        },
        {
          "term": "resource allocation",
          "tier": 2,
          "reasoning": "Domain concept describing how compute resources are distributed to objects."
        },
        {
          "term": "constraints",
          "tier": 2,
          "reasoning": "Technical term describing limitations or rules applied to resource usage."
        },
        {
          "term": "object kinds",
          "tier": 2,
          "reasoning": "Kubernetes concept referring to the types/categories of API objects."
        },
        {
          "term": "ResourceQuotas",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that limits resource consumption per namespace."
        },
        {
          "term": "resource consumption",
          "tier": 2,
          "reasoning": "Domain concept describing the usage of compute resources by workloads."
        },
        {
          "term": "namespace",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for logical partitioning of cluster resources."
        },
        {
          "term": "restrict",
          "tier": 3,
          "reasoning": "Technical action term describing the enforcement behavior of network policies."
        },
        {
          "term": "limit",
          "tier": 3,
          "reasoning": "Technical action term describing the enforcement behavior of resource quotas."
        },
        {
          "term": "ingress and egress traffic",
          "tier": 2,
          "reasoning": "Compound networking concept describing bidirectional network flow control."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:02:51.210860",
      "elapsed_time": 10.827153205871582
    },
    {
      "chunk_id": "concepts_services-networking_ingress_sec7",
      "doc_id": "concepts_services-networking_ingress",
      "heading": "Types of Ingress",
      "source_file": "concepts_services-networking_ingress.md",
      "content": "### Ingress backed by a single Service {#single-service-ingress}\n\nThere are existing Kubernetes concepts that allow you to expose a single Service\n(see [alternatives](#alternatives)). You can also do this with an Ingress by specifying a\n*default backend* with no rules.\n\n{{% code_sample file=\"service/networking/test-ingress.yaml\" %}}\n\nIf you create it using `kubectl apply -f` you should be able to view the state\nof the Ingress you added:\n\n```bash\nkubectl get ingress test-ingress\n```\n\n```\nNAME           CLASS         HOSTS   ADDRESS         PORTS   AGE\ntest-ingress   external-lb   *       203.0.113.123   80      59s\n```\n\nWhere `203.0.113.123` is the IP allocated by the Ingress controller to satisfy\nthis Ingress.\n\n{{< note >}}\nIngress controllers and load balancers may take a minute or two to allocate an IP address.\nUntil that time, you often see the address listed as `<pending>`.\n{{< /note >}}\n\n### Simple fanout\n\nA fanout configuration routes traffic from a single IP address to more than one Service,\nbased on the HTTP URI being requested. An Ingress allows you to keep the number of load balancers\ndown to a minimum. For example, a setup like:\n\n{{< figure src=\"/docs/images/ingressFanOut.svg\" alt=\"ingress-fanout-diagram\" class=\"diagram-large\" caption=\"Figure. Ingress Fan Out\" link=\"https://mermaid.live/edit#pako:eNqNUslOwzAQ_RXLvYCUhMQpUFzUUzkgcUBwbHpw4klr4diR7bCo8O8k2FFbFomLPZq3jP00O1xpDpjijWHtFt09zAuFUCUFKHey8vf6NE7QrdoYsDZumGIb4Oi6NAskNeOoZJKpCgxK4oXwrFVgRyi7nCVXWZKRPMlysv5yD6Q4Xryf1Vq_WzDPooJs9egLNDbolKTpT03JzKgh3zWEztJZ0Niu9L-qZGcdmAMfj4cxvWmreba613z9C0B-AMQD-V_AdA-A4j5QZu0SatRKJhSqhZR0wjmPrDP6CeikrutQxy-Cuy2dtq9RpaU2dJKm6fzI5Glmg0VOLio4_5dLjx27hFSC015KJ2VZHtuQvY2fuHcaE43G0MaCREOow_FV5cMxHZ5-oPX75UM5avuXhXuOI9yAaZjg_aLuBl6B3RYaKDDtSw4166QrcKE-emrXcubghgunDaY1kxYizDqnH99UhakzHYykpWD9hjS--fEJoIELqQ\" >}}\n\nIt would require an Ingress such as:\n\n{{% code_sample file=\"service/networking/simple-fanout-example.yaml\" %}}\n\nWhen you create the Ingress with `kubectl apply -f`:\n\n```shell\nkubectl describe ingress simple-fanout-example\n```\n\n```\nName:             simple-fanout-example\nNamespace:        default\nAddress:          178.91.123.132\nDefault backend:  default-http-backend:80 (10.8.2.3:8080)\nRules:\n  Host         Path  Backends\n  ----         ----  --------\n  foo.bar.com\n               /foo   service1:4200 (10.8.0.90:4200)\n               /bar   service2:8080 (10.8.0.91:8080)\nEvents:\n  Type     Reason  Age                From                     Message\n  ----     ------  ----               ----                     -------\n  Normal   ADD     22s                loadbalancer-controller  default/test\n```\n\nThe Ingress controller provisions an implementation-specific load balancer\nthat satisfies the Ingress, as long as the Services (`service1`, `service2`) exist.\nWhen it has done so, you can see the address of the load balancer at the\nAddress field.\n\n{{< note >}}\nDepending on the [Ingress controller](/docs/concepts/services-networking/ingress-controllers/)\nyou are using, you may need to create a default-http-backend\n[Service](/docs/concepts/services-networking/service/).\n{{< /note >}}\n\n### Name based virtual hosting\n\nName-based virtual hosts support routing HTTP traffic to multiple host names at the same IP address.\n\n{{< figure src=\"/docs/images/ingressNameBased.svg\" alt=\"ingress-namebase-diagram\" class=\"diagram-large\" caption=\"Figure. Ingress Name Based Virtual hosting\" link=\"https://mermaid.live/edit#pako:eNqNkl9PwyAUxb8KYS-atM1Kp05m9qSJJj4Y97jugcLtRqTQAPVPdN_dVlq3qUt8gZt7zvkBN7xjbgRgiteW1Rt0_zjLNUJcSdD-ZBn21WmcoDu9tuBcXDHN1iDQVWHnSBkmUMEU0xwsSuK5DK5l745QejFNLtMkJVmSZmT1Re9NcTz_uDXOU1QakxTMJtxUHw7ss-SQLhehQEODTsdH4l20Q-zFyc84-Y67pghv5apxHuweMuj9eS2_NiJdPhix-kMgvwQShOyYMNkJoEUYM3PuGkpUKyY1KqVSdCSEiJy35gnoqCzLvo5fpPAbOqlfI26UsXQ0Ho9nB5CnqesRGTnncPYvSqsdUvqp9KRdlI6KojjEkB0mnLgjDRONhqENBYm6oXbLV5V1y6S7-l42_LowlIN2uFm_twqOcAW2YlK0H_i9c-bYb6CCHNO2FFCyRvkc53rbWptaMA83QnpjMS2ZchBh1nizeNMcU28bGEzXkrV_pArN7Sc0rBTu\" >}}\n\nThe following Ingress tells the backing load balancer to route requests based on\nthe [Host header](https://tools.ietf.org/html/rfc7230#section-5.4).\n\n{{% code_sample file=\"service/networking/name-virtual-host-ingress.yaml\" %}}\n\nIf you create an Ingress resource without any hosts defined in the rules, then any\nweb traffic to the IP address of your Ingress controller can be matched without a name based\nvirtual host being required.\n\nFor example, the following Ingress routes traffic\nrequested for `first.bar.com` to `service1`, `second.bar.com` to `service2`,\nand any traffic whose request host header doesn't match `first.bar.com`\nand `second.bar.com` to `service3`.\n\n{{% code_sample file=\"service/networking/name-virtual-host-ingress-no-third-host.yaml\" %}}\n\n### TLS\n\nYou can secure an Ingress by specifying a {{< glossary_tooltip term_id=\"secret\" >}}\nthat contains a TLS private key and certificate. The Ingress resource only\nsupports a single TLS port, 443, and assumes TLS termination at the ingress point\n(traffic to the Service and its Pods is in plaintext).\nIf the TLS configuration section in an Ingress specifies different hosts, they are\nmultiplexed on the same port according to the hostname specified through the\nSNI TLS extension (provided the Ingress controller supports SNI). The TLS secret\nmust contain keys named `tls.crt` and `tls.key` that contain the certificate\nand private key to use for TLS. For example:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: testsecret-tls\n  namespace: default\ndata:\n  tls.crt: base64 encoded cert\n  tls.key: base64 encoded key\ntype: kubernetes.io/tls\n```\n\nReferencing this secret in an Ingress tells the Ingress controller to\nsecure the channel from the client to the load balancer using TLS. You need to make\nsure the TLS secret you created came from a certificate that contains a Common\nName (CN), also known as a Fully Qualified Domain Name (FQDN) for `https-example.foo.com`.\n\n{{< note >}}\nKeep in mind that TLS will not work on the default rule because the\ncertificates would have to be issued for all the possible sub-domains. Therefore,\n`hosts` in the `tls` section need to explicitly match the `host` in the `rules`\nsection.\n{{< /note >}}\n\n{{% code_sample file=\"service/networking/tls-example-ingress.yaml\" %}}\n\n{{< note >}}\nThere is a gap between TLS features supported by various ingress controllers.\nYou should refer to the documentation for the ingress controller(s) you've chosen to\nunderstand how TLS works in your environment.\n{{< /note >}}\n\n### Load balancing {#load-balancing}\n\nAn Ingress controller is bootstrapped with some load balancing policy settings\nthat it applies to all Ingress, such as the load balancing algorithm, backend\nweight scheme, and others. More advanced load balancing concepts\n(e.g. persistent sessions, dynamic weights) are not yet exposed through the\nIngress. You can instead get these features through the load balancer used for\na Service.\n\nIt's also worth noting that even though health checks are not exposed directly\nthrough the Ingress, there exist parallel concepts in Kubernetes such as\n[readiness probes](/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)\nthat allow you to achieve the same end result. Please review the controller\nspecific documentation to see how they handle health checks.",
      "terms": [
        {
          "term": "Ingress",
          "tier": 1,
          "reasoning": "Core Kubernetes API object for managing external access to services in a cluster."
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object that exposes applications running on pods."
        },
        {
          "term": "default backend",
          "tier": 2,
          "reasoning": "Ingress configuration concept specifying where traffic goes when no rules match."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool used for cluster management."
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Specific kubectl command for applying configuration to resources."
        },
        {
          "term": "kubectl get",
          "tier": 1,
          "reasoning": "Specific kubectl command for retrieving resource information."
        },
        {
          "term": "kubectl describe",
          "tier": 1,
          "reasoning": "Specific kubectl command for showing detailed resource information."
        },
        {
          "term": "Ingress controller",
          "tier": 1,
          "reasoning": "Kubernetes component that implements Ingress resources and manages load balancing."
        },
        {
          "term": "load balancer",
          "tier": 2,
          "reasoning": "Infrastructure component that distributes network traffic across multiple services."
        },
        {
          "term": "IP address",
          "tier": 3,
          "reasoning": "Network addressing concept used for routing traffic to Ingress resources."
        },
        {
          "term": "fanout",
          "tier": 2,
          "reasoning": "Ingress routing pattern that distributes traffic from single IP to multiple services."
        },
        {
          "term": "HTTP URI",
          "tier": 3,
          "reasoning": "Protocol-specific identifier used for path-based routing decisions."
        },
        {
          "term": "HTTP",
          "tier": 3,
          "reasoning": "Application layer protocol used for Ingress traffic routing."
        },
        {
          "term": "Name based virtual hosting",
          "tier": 2,
          "reasoning": "Ingress routing technique supporting multiple hostnames at same IP address."
        },
        {
          "term": "virtual hosting",
          "tier": 2,
          "reasoning": "Networking concept for hosting multiple domains on single IP address."
        },
        {
          "term": "host names",
          "tier": 3,
          "reasoning": "DNS names used for name-based virtual hosting routing."
        },
        {
          "term": "Namespace",
          "tier": 1,
          "reasoning": "Kubernetes resource for organizing and isolating cluster resources."
        },
        {
          "term": "default-http-backend",
          "tier": 1,
          "reasoning": "Specific Service name required by some Ingress controllers for fallback routing."
        },
        {
          "term": "Address",
          "tier": 2,
          "reasoning": "Ingress field showing the allocated external IP for the resource."
        },
        {
          "term": "Rules",
          "tier": 2,
          "reasoning": "Ingress configuration section defining routing paths and backends."
        },
        {
          "term": "Host",
          "tier": 2,
          "reasoning": "Ingress rule field specifying the hostname for routing."
        },
        {
          "term": "Path",
          "tier": 2,
          "reasoning": "Ingress rule field specifying URL path for routing decisions."
        },
        {
          "term": "Backends",
          "tier": 2,
          "reasoning": "Ingress configuration specifying target services for routed traffic."
        },
        {
          "term": "PORTS",
          "tier": 2,
          "reasoning": "Network ports exposed by the Ingress resource."
        },
        {
          "term": "CLASS",
          "tier": 2,
          "reasoning": "Ingress field specifying which Ingress controller should handle the resource."
        },
        {
          "term": "external-lb",
          "tier": 1,
          "reasoning": "Specific Ingress class name shown in example output."
        },
        {
          "term": "test-ingress",
          "tier": 1,
          "reasoning": "Example Ingress resource name used in documentation."
        },
        {
          "term": "simple-fanout-example",
          "tier": 1,
          "reasoning": "Example Ingress resource name demonstrating fanout configuration."
        },
        {
          "term": "service1",
          "tier": 1,
          "reasoning": "Example Service name used as backend in fanout configuration."
        },
        {
          "term": "service2",
          "tier": 1,
          "reasoning": "Example Service name used as backend in fanout configuration."
        },
        {
          "term": "foo.bar.com",
          "tier": 3,
          "reasoning": "Example hostname used in Ingress routing rules."
        },
        {
          "term": "loadbalancer-controller",
          "tier": 1,
          "reasoning": "Component name shown in Events that manages load balancer provisioning."
        },
        {
          "term": "Events",
          "tier": 2,
          "reasoning": "Kubernetes resource field showing lifecycle events for resources."
        },
        {
          "term": "traffic",
          "tier": 2,
          "reasoning": "Network traffic concept central to Ingress routing functionality."
        },
        {
          "term": "routing",
          "tier": 2,
          "reasoning": "Network concept for directing traffic to appropriate destinations."
        }
      ],
      "term_count": 35,
      "generated_at": "2026-02-08T21:03:15.113496",
      "elapsed_time": 22.899235486984253
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec19",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`Key`     {#apiserver-config-k8s-io-v1-Key}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [AESConfiguration](#apiserver-config-k8s-io-v1-AESConfiguration)\n\n- [SecretboxConfiguration](#apiserver-config-k8s-io-v1-SecretboxConfiguration)\n\n\n<p>Key contains name and secret of the provided key for a transformer.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>name</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>name is the name of the key to be used while storing data to disk.</p>\n</td>\n</tr>\n<tr><td><code>secret</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>secret is the actual key, encoded in base64.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AESConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for AES encryption settings."
        },
        {
          "term": "SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for Secretbox encryption settings."
        },
        {
          "term": "Key",
          "tier": 1,
          "reasoning": "Named API object/struct that contains name and secret for a transformer."
        },
        {
          "term": "transformer",
          "tier": 2,
          "reasoning": "Domain concept referring to a component that transforms/encrypts data in Kubernetes."
        },
        {
          "term": "name",
          "tier": 2,
          "reasoning": "Required field identifier used for storing data to disk in encryption context."
        },
        {
          "term": "secret",
          "tier": 2,
          "reasoning": "Domain term referring to the actual encryption key material."
        },
        {
          "term": "base64",
          "tier": 3,
          "reasoning": "Encoding standard used for representing the secret key."
        },
        {
          "term": "apiserver-config-k8s-io-v1-AESConfiguration",
          "tier": 1,
          "reasoning": "Full API group/version/kind reference for AESConfiguration resource."
        },
        {
          "term": "apiserver-config-k8s-io-v1-SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Full API group/version/kind reference for SecretboxConfiguration resource."
        },
        {
          "term": "disk",
          "tier": 3,
          "reasoning": "Storage medium referenced in context of data persistence."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term describing API object structure components."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the name and secret fields."
        },
        {
          "term": "encoded",
          "tier": 3,
          "reasoning": "Technical term describing the transformation applied to the secret key."
        }
      ],
      "term_count": 13,
      "generated_at": "2026-02-08T21:03:25.040628",
      "elapsed_time": 8.92354154586792
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1beta1_sec6",
      "doc_id": "reference_config-api_apiserver-config.v1beta1",
      "heading": "`AnonymousAuthCondition`     {#apiserver-k8s-io-v1beta1-AnonymousAuthCondition}",
      "source_file": "reference_config-api_apiserver-config.v1beta1.md",
      "content": "**Appears in:**\n\n- [AnonymousAuthConfig](#apiserver-k8s-io-v1beta1-AnonymousAuthConfig)\n\n\n<p>AnonymousAuthCondition describes the condition under which anonymous auth\nshould be enabled.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>path</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>Path for which anonymous auth is enabled.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AnonymousAuthConfig",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for anonymous authentication settings."
        },
        {
          "term": "AnonymousAuthCondition",
          "tier": 1,
          "reasoning": "Named Kubernetes API type that describes conditions for anonymous authentication."
        },
        {
          "term": "apiserver-k8s-io-v1beta1",
          "tier": 1,
          "reasoning": "Kubernetes API group and version identifier for the apiserver configuration."
        },
        {
          "term": "anonymous auth",
          "tier": 2,
          "reasoning": "Domain concept referring to authentication mechanism allowing unauthenticated access."
        },
        {
          "term": "path",
          "tier": 2,
          "reasoning": "Technical field specifying the URL path for which anonymous authentication applies."
        },
        {
          "term": "condition",
          "tier": 2,
          "reasoning": "Domain concept describing a state or requirement that must be met for a feature to be enabled."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term referring to a data attribute in an API object specification."
        },
        {
          "term": "v1beta1",
          "tier": 2,
          "reasoning": "API version indicating beta maturity level in Kubernetes API versioning."
        },
        {
          "term": "enabled",
          "tier": 3,
          "reasoning": "Technical state indicating a feature or capability is active."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the path field value."
        }
      ],
      "term_count": 10,
      "generated_at": "2026-02-08T21:03:32.332301",
      "elapsed_time": 6.287521123886108
    },
    {
      "chunk_id": "tasks_administer-cluster_coredns_sec3",
      "doc_id": "tasks_administer-cluster_coredns",
      "heading": "Upgrading CoreDNS",
      "source_file": "tasks_administer-cluster_coredns.md",
      "content": "You can check the version of CoreDNS that kubeadm installs for each version of\nKubernetes in the page\n[CoreDNS version in Kubernetes](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md).\n\nCoreDNS can be upgraded manually in case you want to only upgrade CoreDNS\nor use your own custom image.\nThere is a helpful [guideline and walkthrough](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md)\navailable to ensure a smooth upgrade.\nMake sure the existing CoreDNS configuration (\"Corefile\") is retained when\nupgrading your cluster.\n\nIf you are upgrading your cluster using the `kubeadm` tool, `kubeadm`\ncan take care of retaining the existing CoreDNS configuration automatically.",
      "terms": [
        {
          "term": "CoreDNS",
          "tier": 1,
          "reasoning": "Core Kubernetes DNS component and proper noun for the DNS server used in Kubernetes clusters."
        },
        {
          "term": "kubeadm",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool for cluster bootstrapping and management."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the primary subject domain."
        },
        {
          "term": "Corefile",
          "tier": 1,
          "reasoning": "CoreDNS-specific configuration file name, a proper noun for the configuration resource."
        },
        {
          "term": "CoreDNS configuration",
          "tier": 2,
          "reasoning": "Domain concept referring to the settings and parameters that define CoreDNS behavior."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes architectural concept referring to a set of nodes running containerized applications."
        },
        {
          "term": "upgrade",
          "tier": 2,
          "reasoning": "Technical process of updating software components to newer versions in Kubernetes context."
        },
        {
          "term": "upgrading",
          "tier": 2,
          "reasoning": "Technical process term as it appears in the text describing the update procedure."
        },
        {
          "term": "version",
          "tier": 2,
          "reasoning": "Technical concept referring to specific releases of software components."
        },
        {
          "term": "custom image",
          "tier": 2,
          "reasoning": "Container/Kubernetes concept referring to user-defined container images."
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Core container concept referring to container images used in Kubernetes."
        },
        {
          "term": "configuration",
          "tier": 2,
          "reasoning": "Technical concept for settings and parameters that control system behavior."
        },
        {
          "term": "CoreDNS version",
          "tier": 2,
          "reasoning": "Specific versioning concept for the CoreDNS component within Kubernetes."
        },
        {
          "term": "manually",
          "tier": 3,
          "reasoning": "Operational term describing a non-automated upgrade approach."
        },
        {
          "term": "walkthrough",
          "tier": 3,
          "reasoning": "Documentation/operational term for step-by-step guidance in technical procedures."
        },
        {
          "term": "guideline",
          "tier": 3,
          "reasoning": "Technical documentation term for recommended practices."
        },
        {
          "term": "tool",
          "tier": 3,
          "reasoning": "General technical term referring to CLI utilities like kubeadm."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:03:45.101347",
      "elapsed_time": 11.765461683273315
    },
    {
      "chunk_id": "tasks_debug_debug-application_debug-statefulset_sec1",
      "doc_id": "tasks_debug_debug-application_debug-statefulset",
      "heading": "{{% heading \"prerequisites\" %}}",
      "source_file": "tasks_debug_debug-application_debug-statefulset.md",
      "content": "* You need to have a Kubernetes cluster, and the kubectl command-line tool must be configured to communicate with your cluster.\n* You should have a StatefulSet running that you want to investigate.\n\n<!-- steps -->",
      "terms": [
        {
          "term": "Kubernetes cluster",
          "tier": 1,
          "reasoning": "Core infrastructure resource - a complete Kubernetes deployment environment"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the primary subject of this documentation"
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental architectural concept referring to a set of nodes running containerized applications"
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool for cluster management and communication"
        },
        {
          "term": "command-line tool",
          "tier": 2,
          "reasoning": "Technical term describing the type of interface kubectl provides"
        },
        {
          "term": "configured",
          "tier": 3,
          "reasoning": "Technical process term referring to setting up tool parameters for cluster communication"
        },
        {
          "term": "communicate",
          "tier": 3,
          "reasoning": "Technical term in context referring to API communication between kubectl and cluster"
        },
        {
          "term": "StatefulSet",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/workload resource for managing stateful applications"
        },
        {
          "term": "running",
          "tier": 3,
          "reasoning": "Technical state term describing an active workload in Kubernetes context"
        }
      ],
      "term_count": 9,
      "generated_at": "2026-02-08T21:03:52.701677",
      "elapsed_time": 6.596871376037598
    },
    {
      "chunk_id": "concepts_overview_working-with-objects_annotations_sec1",
      "doc_id": "concepts_overview_working-with-objects_annotations",
      "heading": "Attaching metadata to objects",
      "source_file": "concepts_overview_working-with-objects_annotations.md",
      "content": "You can use either labels or annotations to attach metadata to Kubernetes\nobjects. Labels can be used to select objects and to find\ncollections of objects that satisfy certain conditions. In contrast, annotations\nare not used to identify and select objects. The metadata\nin an annotation can be small or large, structured or unstructured, and can\ninclude characters not permitted by labels. It is possible to use labels as \nwell as annotations in the metadata of the same object.\n\nAnnotations, like labels, are key/value maps:\n\n```json\n\"metadata\": {\n  \"annotations\": {\n    \"key1\" : \"value1\",\n    \"key2\" : \"value2\"\n  }\n}\n```\n\n{{<note>}}\nThe keys and the values in the map must be strings. In other words, you cannot use\nnumeric, boolean, list or other types for either the keys or the values.\n{{</note>}}\n\nHere are some examples of information that could be recorded in annotations:\n\n* Fields managed by a declarative configuration layer. Attaching these fields\n  as annotations distinguishes them from default values set by clients or\n  servers, and from auto-generated fields and fields set by\n  auto-sizing or auto-scaling systems.\n\n* Build, release, or image information like timestamps, release IDs, git branch,\n  PR numbers, image hashes, and registry address.\n\n* Pointers to logging, monitoring, analytics, or audit repositories.\n\n* Client library or tool information that can be used for debugging purposes:\n  for example, name, version, and build information.\n\n* User or tool/system provenance information, such as URLs of related objects\n  from other ecosystem components.\n\n* Lightweight rollout tool metadata: for example, config or checkpoints.\n\n* Phone or pager numbers of persons responsible, or directory entries that\n  specify where that information can be found, such as a team web site.\n\n* Directives from the end-user to the implementations to modify behavior or\n  engage non-standard features.\n\nInstead of using annotations, you could store this type of information in an\nexternal database or directory, but that would make it much harder to produce\nshared client libraries and tools for deployment, management, introspection,\nand the like.",
      "terms": [
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for attaching metadata to objects for selection and identification"
        },
        {
          "term": "annotations",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for attaching non-identifying metadata to objects"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Technical concept referring to data about Kubernetes objects"
        },
        {
          "term": "key/value maps",
          "tier": 3,
          "reasoning": "Data structure concept describing how annotations and labels are stored"
        },
        {
          "term": "strings",
          "tier": 3,
          "reasoning": "Data type constraint for annotation keys and values"
        },
        {
          "term": "declarative configuration layer",
          "tier": 2,
          "reasoning": "Architectural concept describing configuration management approach in Kubernetes"
        },
        {
          "term": "clients",
          "tier": 3,
          "reasoning": "Technical term referring to systems that interact with Kubernetes API"
        },
        {
          "term": "servers",
          "tier": 3,
          "reasoning": "Technical term referring to systems that serve Kubernetes API"
        },
        {
          "term": "auto-generated fields",
          "tier": 2,
          "reasoning": "Domain concept for fields automatically created by Kubernetes"
        },
        {
          "term": "auto-sizing",
          "tier": 2,
          "reasoning": "Domain concept for automatic resource sizing systems"
        },
        {
          "term": "auto-scaling systems",
          "tier": 2,
          "reasoning": "Domain concept for systems that automatically scale resources"
        },
        {
          "term": "release IDs",
          "tier": 3,
          "reasoning": "Technical metadata concept for identifying software releases"
        },
        {
          "term": "git branch",
          "tier": 3,
          "reasoning": "Version control concept used in build metadata"
        },
        {
          "term": "PR numbers",
          "tier": 3,
          "reasoning": "Pull request identifiers used in build metadata"
        },
        {
          "term": "image hashes",
          "tier": 2,
          "reasoning": "Container image identification concept"
        },
        {
          "term": "registry address",
          "tier": 2,
          "reasoning": "Container registry location concept"
        },
        {
          "term": "logging",
          "tier": 2,
          "reasoning": "Observability concept for recording system events"
        },
        {
          "term": "monitoring",
          "tier": 2,
          "reasoning": "Observability concept for tracking system health"
        },
        {
          "term": "analytics",
          "tier": 2,
          "reasoning": "Observability concept for analyzing system data"
        },
        {
          "term": "audit repositories",
          "tier": 2,
          "reasoning": "Security/compliance concept for storing audit data"
        },
        {
          "term": "client library",
          "tier": 3,
          "reasoning": "Technical term for SDK/libraries interacting with Kubernetes"
        },
        {
          "term": "debugging",
          "tier": 3,
          "reasoning": "Technical process for troubleshooting issues"
        },
        {
          "term": "provenance information",
          "tier": 2,
          "reasoning": "Domain concept for tracking origin and history of resources"
        },
        {
          "term": "ecosystem components",
          "tier": 2,
          "reasoning": "Architectural term for related systems in Kubernetes ecosystem"
        },
        {
          "term": "rollout tool",
          "tier": 2,
          "reasoning": "Deployment concept for tools managing application rollouts"
        },
        {
          "term": "config",
          "tier": 3,
          "reasoning": "Technical shorthand for configuration data"
        },
        {
          "term": "checkpoints",
          "tier": 2,
          "reasoning": "Technical concept for saving state during rollouts"
        },
        {
          "term": "deployment",
          "tier": 2,
          "reasoning": "Domain concept for deploying applications (used in context of management)"
        },
        {
          "term": "management",
          "tier": 3,
          "reasoning": "Operational concept for administering Kubernetes resources"
        },
        {
          "term": "introspection",
          "tier": 2,
          "reasoning": "Technical concept for examining system state"
        },
        {
          "term": "external database",
          "tier": 3,
          "reasoning": "Infrastructure concept for storing data outside Kubernetes"
        },
        {
          "term": "directory",
          "tier": 3,
          "reasoning": "Technical concept for external data storage systems"
        },
        {
          "term": "shared client libraries",
          "tier": 2,
          "reasoning": "Technical concept for reusable code libraries across tools"
        },
        {
          "term": "timestamps",
          "tier": 3,
          "reasoning": "Technical metadata concept for recording time information"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container image concept used in build information context"
        }
      ],
      "term_count": 35,
      "generated_at": "2026-02-08T21:04:09.821062",
      "elapsed_time": 16.114391326904297
    },
    {
      "chunk_id": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster_sec7",
      "doc_id": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster",
      "heading": "{{% heading \"whatsnext\" %}}",
      "source_file": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster.md",
      "content": "* [Learn more about DRA](/docs/concepts/scheduling-eviction/dynamic-resource-allocation)\n* [Allocate Devices to Workloads with DRA](/docs/tasks/configure-pod-container/assign-resources/allocate-devices-dra)",
      "terms": [
        {
          "term": "DRA",
          "tier": 1,
          "reasoning": "Abbreviation for Dynamic Resource Allocation, a specific Kubernetes feature/API for resource management."
        },
        {
          "term": "Dynamic Resource Allocation",
          "tier": 1,
          "reasoning": "Implied by the DRA abbreviation in the URL path, this is a core Kubernetes scheduling feature."
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Domain concept appearing in the URL path 'scheduling-eviction', referring to the Kubernetes scheduling process."
        },
        {
          "term": "eviction",
          "tier": 2,
          "reasoning": "Domain concept appearing in the URL path 'scheduling-eviction', referring to the process of removing pods from nodes."
        },
        {
          "term": "Devices",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context referring to hardware resources that can be allocated to workloads."
        },
        {
          "term": "Workloads",
          "tier": 2,
          "reasoning": "Domain concept referring to applications or jobs running in Kubernetes that consume resources."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Core Kubernetes API object implied by 'configure-pod-container' in the URL path."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept appearing in the URL path 'configure-pod-container'."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Technical term appearing in 'assign-resources' and 'Dynamic Resource Allocation', referring to compute resources in Kubernetes."
        },
        {
          "term": "Allocate",
          "tier": 2,
          "reasoning": "Technical process term describing the action of assigning resources to workloads in Kubernetes."
        },
        {
          "term": "allocate-devices-dra",
          "tier": 3,
          "reasoning": "Specific documentation path/task identifier for device allocation using DRA."
        }
      ],
      "term_count": 11,
      "generated_at": "2026-02-08T21:04:18.811528",
      "elapsed_time": 7.9841883182525635
    },
    {
      "chunk_id": "reference_config-api_apiserver-admission.v1_sec2",
      "doc_id": "reference_config-api_apiserver-admission.v1",
      "heading": "`AdmissionResponse`     {#admission-k8s-io-v1-AdmissionResponse}",
      "source_file": "reference_config-api_apiserver-admission.v1.md",
      "content": "**Appears in:**\n\n- [AdmissionReview](#admission-k8s-io-v1-AdmissionReview)\n\n\n<p>AdmissionResponse describes an admission response.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>uid</code> <B>[Required]</B><br/>\n<a href=\"https://pkg.go.dev/k8s.io/apimachinery/pkg/types#UID\"><code>k8s.io/apimachinery/pkg/types.UID</code></a>\n</td>\n<td>\n   <p>uid is an identifier for the individual request/response.\nThis must be copied over from the corresponding AdmissionRequest.</p>\n</td>\n</tr>\n<tr><td><code>allowed</code> <B>[Required]</B><br/>\n<code>bool</code>\n</td>\n<td>\n   <p>allowed indicates whether or not the admission request was permitted.</p>\n</td>\n</tr>\n<tr><td><code>status</code><br/>\n<a href=\"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.35/#status-v1-meta\"><code>meta/v1.Status</code></a>\n</td>\n<td>\n   <p>status is the result contains extra details into why an admission request was denied.\nThis field IS NOT consulted in any way if &quot;Allowed&quot; is &quot;true&quot;.</p>\n</td>\n</tr>\n<tr><td><code>patch</code><br/>\n<code>[]byte</code>\n</td>\n<td>\n   <p>patch is the patch body. Currently we only support &quot;JSONPatch&quot; which implements RFC 6902.</p>\n</td>\n</tr>\n<tr><td><code>patchType</code><br/>\n<a href=\"#admission-k8s-io-v1-PatchType\"><code>PatchType</code></a>\n</td>\n<td>\n   <p>patchType is the type of Patch. Currently we only allow &quot;JSONPatch&quot;.</p>\n</td>\n</tr>\n<tr><td><code>auditAnnotations</code><br/>\n<code>map[string]string</code>\n</td>\n<td>\n   <p>auditAnnotations is an unstructured key value map set by remote admission controller (e.g. error=image-blacklisted).\nMutatingAdmissionWebhook and ValidatingAdmissionWebhook admission controller will prefix the keys with\nadmission webhook name (e.g. imagepolicy.example.com/error=image-blacklisted). AuditAnnotations will be provided by\nthe admission webhook to add additional context to the audit log for this request.</p>\n</td>\n</tr>\n<tr><td><code>warnings</code><br/>\n<code>[]string</code>\n</td>\n<td>\n   <p>warnings is a list of warning messages to return to the requesting API client.\nWarning messages describe a problem the client making the API request should correct or be aware of.\nLimit warnings to 120 characters if possible.\nWarnings over 256 characters and large numbers of warnings may be truncated.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AdmissionReview",
          "tier": 1,
          "reasoning": "Kubernetes API object for admission control review requests and responses."
        },
        {
          "term": "AdmissionResponse",
          "tier": 1,
          "reasoning": "Kubernetes API object that describes an admission response structure."
        },
        {
          "term": "AdmissionRequest",
          "tier": 1,
          "reasoning": "Kubernetes API object representing an admission request that AdmissionResponse corresponds to."
        },
        {
          "term": "uid",
          "tier": 2,
          "reasoning": "Field identifier for individual request/response tracking in admission control."
        },
        {
          "term": "UID",
          "tier": 2,
          "reasoning": "Type reference from k8s.io/apimachinery for unique identifiers."
        },
        {
          "term": "k8s.io/apimachinery/pkg/types.UID",
          "tier": 1,
          "reasoning": "Full package path reference to the UID type in Kubernetes apimachinery."
        },
        {
          "term": "allowed",
          "tier": 2,
          "reasoning": "Boolean field indicating whether an admission request was permitted."
        },
        {
          "term": "status",
          "tier": 2,
          "reasoning": "Field containing extra details about why an admission request was denied."
        },
        {
          "term": "meta/v1.Status",
          "tier": 1,
          "reasoning": "Kubernetes API type reference for status information in meta/v1 API group."
        },
        {
          "term": "patch",
          "tier": 2,
          "reasoning": "Field containing the patch body for mutating admission responses."
        },
        {
          "term": "JSONPatch",
          "tier": 2,
          "reasoning": "Patch format implementing RFC 6902 for JSON document modifications."
        },
        {
          "term": "RFC 6902",
          "tier": 3,
          "reasoning": "Internet standard specification for JSON Patch operations."
        },
        {
          "term": "patchType",
          "tier": 2,
          "reasoning": "Field specifying the type of patch being applied in admission response."
        },
        {
          "term": "PatchType",
          "tier": 1,
          "reasoning": "Kubernetes API type for specifying patch format in admission control."
        },
        {
          "term": "auditAnnotations",
          "tier": 2,
          "reasoning": "Key-value map for adding context to audit logs from admission controllers."
        },
        {
          "term": "audit log",
          "tier": 2,
          "reasoning": "Kubernetes logging mechanism for recording API request details."
        },
        {
          "term": "remote admission controller",
          "tier": 2,
          "reasoning": "External webhook-based admission controller processing requests."
        },
        {
          "term": "admission controller",
          "tier": 2,
          "reasoning": "Kubernetes component that intercepts and validates/mutates API requests."
        },
        {
          "term": "MutatingAdmissionWebhook",
          "tier": 1,
          "reasoning": "Kubernetes admission controller type that can modify incoming API requests."
        },
        {
          "term": "ValidatingAdmissionWebhook",
          "tier": 1,
          "reasoning": "Kubernetes admission controller type that validates incoming API requests."
        },
        {
          "term": "admission webhook",
          "tier": 2,
          "reasoning": "HTTP callback mechanism for external admission control logic."
        },
        {
          "term": "warnings",
          "tier": 2,
          "reasoning": "Field containing warning messages returned to API clients about request issues."
        },
        {
          "term": "API client",
          "tier": 2,
          "reasoning": "Client making requests to the Kubernetes API server."
        },
        {
          "term": "admission request",
          "tier": 2,
          "reasoning": "Request sent to admission controllers for validation or mutation."
        },
        {
          "term": "admission-k8s-io-v1-AdmissionReview",
          "tier": 1,
          "reasoning": "Full API reference identifier for AdmissionReview in admission.k8s.io/v1."
        },
        {
          "term": "admission-k8s-io-v1-PatchType",
          "tier": 1,
          "reasoning": "Full API reference identifier for PatchType in admission.k8s.io/v1."
        },
        {
          "term": "bool",
          "tier": 3,
          "reasoning": "Boolean data type used for the allowed field."
        },
        {
          "term": "[]byte",
          "tier": 3,
          "reasoning": "Go byte slice type used for patch body data."
        },
        {
          "term": "map[string]string",
          "tier": 3,
          "reasoning": "Go map type used for auditAnnotations key-value pairs."
        },
        {
          "term": "[]string",
          "tier": 3,
          "reasoning": "Go string slice type used for warnings list."
        }
      ],
      "term_count": 30,
      "generated_at": "2026-02-08T21:04:40.193970",
      "elapsed_time": 20.378008365631104
    },
    {
      "chunk_id": "tasks_run-application_configure-pdb_sec1",
      "doc_id": "tasks_run-application_configure-pdb",
      "heading": "{{% heading \"prerequisites\" %}}",
      "source_file": "tasks_run-application_configure-pdb.md",
      "content": "{{< version-check >}}\n\n- You are the owner of an application running on a Kubernetes cluster that requires\n  high availability.\n- You should know how to deploy [Replicated Stateless Applications](/docs/tasks/run-application/run-stateless-application-deployment/)\n  and/or [Replicated Stateful Applications](/docs/tasks/run-application/run-replicated-stateful-application/).\n- You should have read about [Pod Disruptions](/docs/concepts/workloads/pods/disruptions/).\n- You should confirm with your cluster owner or service provider that they respect\n  Pod Disruption Budgets.\n\n<!-- steps -->",
      "terms": [
        {
          "term": "Kubernetes cluster",
          "tier": 1,
          "reasoning": "Core infrastructure resource - the primary container orchestration platform being discussed."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the central subject of this documentation."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental architectural concept referring to a set of nodes running containerized applications."
        },
        {
          "term": "high availability",
          "tier": 2,
          "reasoning": "Critical architectural concept describing system design for continuous operation."
        },
        {
          "term": "application",
          "tier": 2,
          "reasoning": "Technical term referring to workloads running on the cluster."
        },
        {
          "term": "Replicated Stateless Applications",
          "tier": 1,
          "reasoning": "Specific Kubernetes workload pattern and documentation reference for applications without persistent state."
        },
        {
          "term": "Replicated Stateful Applications",
          "tier": 1,
          "reasoning": "Specific Kubernetes workload pattern for applications that maintain persistent state."
        },
        {
          "term": "Stateless Applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications that don't maintain state between requests."
        },
        {
          "term": "Stateful Applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications that maintain persistent state."
        },
        {
          "term": "Pod Disruptions",
          "tier": 1,
          "reasoning": "Core Kubernetes concept referring to events that cause Pods to become unavailable."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object - the smallest deployable unit."
        },
        {
          "term": "Pod Disruption Budgets",
          "tier": 1,
          "reasoning": "Specific Kubernetes API resource (PDB) that limits voluntary disruptions to Pods."
        },
        {
          "term": "cluster owner",
          "tier": 2,
          "reasoning": "Role-based term describing the administrator responsible for cluster management."
        },
        {
          "term": "service provider",
          "tier": 2,
          "reasoning": "Technical role term referring to entities providing Kubernetes infrastructure services."
        },
        {
          "term": "deploy",
          "tier": 2,
          "reasoning": "Core operational process for releasing applications to a cluster."
        },
        {
          "term": "owner",
          "tier": 3,
          "reasoning": "Contextual term referring to the entity responsible for an application workload."
        }
      ],
      "term_count": 16,
      "generated_at": "2026-02-08T21:04:50.506896",
      "elapsed_time": 9.308373212814331
    },
    {
      "chunk_id": "tasks_inject-data-application_downward-api-volume-expose-pod-information_sec2",
      "doc_id": "tasks_inject-data-application_downward-api-volume-expose-pod-information",
      "heading": "Store container fields",
      "source_file": "tasks_inject-data-application_downward-api-volume-expose-pod-information.md",
      "content": "The preceding exercise, you made Pod-level fields accessible using the\ndownward API.\nIn this next exercise, you are going to pass fields that are part of the Pod\ndefinition, but taken from the specific\n[container](/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container)\nrather than from the Pod overall. Here is a manifest for a Pod that again has\njust one container:\n\n{{% code_sample file=\"pods/inject/dapi-volume-resources.yaml\" %}}\n\nIn the manifest, you can see that the Pod has a\n[`downwardAPI` volume](/docs/concepts/storage/volumes/#downwardapi),\nand that the single container in that Pod mounts the volume at `/etc/podinfo`.\n\nLook at the `items` array under `downwardAPI`. Each element of the array\ndefines a file in the downward API volume.\n\nThe first element specifies that in the container named `client-container`,\nthe value of the `limits.cpu` field in the format specified by `1m` should be\npublished as a file named `cpu_limit`. The `divisor` field is optional and has the\ndefault value of `1`. A divisor of 1 means cores for `cpu` resources, or\nbytes for `memory` resources.\n\nCreate the Pod:\n\n```shell\nkubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume-resources.yaml\n```\n\nGet a shell into the container that is running in your Pod:\n\n```shell\nkubectl exec -it kubernetes-downwardapi-volume-example-2 -- sh\n```\n\nIn your shell, view the `cpu_limit` file:\n\n```shell",
      "terms": [
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Core Kubernetes API object and workload resource explicitly discussed throughout the chunk."
        },
        {
          "term": "downward API",
          "tier": 1,
          "reasoning": "Specific Kubernetes feature for exposing Pod and container information to containers."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept representing the runtime unit within a Pod."
        },
        {
          "term": "Pod-level fields",
          "tier": 2,
          "reasoning": "Technical concept referring to metadata and spec fields defined at the Pod scope."
        },
        {
          "term": "manifest",
          "tier": 2,
          "reasoning": "Technical term for the YAML/JSON file that declares Kubernetes resources."
        },
        {
          "term": "downwardAPI volume",
          "tier": 1,
          "reasoning": "Specific Kubernetes volume type that exposes Pod/container information as files."
        },
        {
          "term": "volume",
          "tier": 2,
          "reasoning": "Core Kubernetes storage concept for providing persistent or ephemeral storage to containers."
        },
        {
          "term": "client-container",
          "tier": 1,
          "reasoning": "Specific container name referenced in the example manifest."
        },
        {
          "term": "limits.cpu",
          "tier": 2,
          "reasoning": "Kubernetes resource field specifying CPU resource limits for a container."
        },
        {
          "term": "divisor",
          "tier": 2,
          "reasoning": "Technical field in downward API configuration that specifies unit conversion."
        },
        {
          "term": "cpu",
          "tier": 3,
          "reasoning": "Computing resource type managed by Kubernetes resource limits and requests."
        },
        {
          "term": "memory",
          "tier": 3,
          "reasoning": "Computing resource type managed by Kubernetes resource limits and requests."
        },
        {
          "term": "cores",
          "tier": 3,
          "reasoning": "Unit of CPU measurement referenced in the context of resource divisors."
        },
        {
          "term": "bytes",
          "tier": 3,
          "reasoning": "Unit of memory measurement referenced in the context of resource divisors."
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Kubernetes CLI command for creating or updating resources declaratively."
        },
        {
          "term": "kubectl exec",
          "tier": 1,
          "reasoning": "Kubernetes CLI command for executing commands inside a container."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes command-line interface tool."
        },
        {
          "term": "shell",
          "tier": 3,
          "reasoning": "Command-line interface context for interacting with containers."
        },
        {
          "term": "cpu_limit",
          "tier": 2,
          "reasoning": "Specific file name created by downward API to expose CPU limit information."
        },
        {
          "term": "kubernetes-downwardapi-volume-example-2",
          "tier": 1,
          "reasoning": "Specific Pod name used in the example commands."
        },
        {
          "term": "mounts",
          "tier": 2,
          "reasoning": "Technical term for attaching volumes to container filesystem paths."
        },
        {
          "term": "/etc/podinfo",
          "tier": 2,
          "reasoning": "Specific mount path where downward API volume is attached in the example."
        },
        {
          "term": "1m",
          "tier": 2,
          "reasoning": "Kubernetes resource quantity format representing millicores for CPU."
        },
        {
          "term": "file",
          "tier": 3,
          "reasoning": "Filesystem object created by downward API volume to expose information."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Kubernetes concept for CPU and memory allocations to containers."
        }
      ],
      "term_count": 25,
      "generated_at": "2026-02-08T21:05:06.267972",
      "elapsed_time": 14.756489276885986
    },
    {
      "chunk_id": "tasks_manage-kubernetes-objects_kustomization_sec10",
      "doc_id": "tasks_manage-kubernetes-objects_kustomization",
      "heading": "Create a deployment.yaml file",
      "source_file": "tasks_manage-kubernetes-objects_kustomization.md",
      "content": "cat <<EOF > deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-nginx\nspec:\n  selector:\n    matchLabels:\n      run: my-nginx\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        run: my-nginx\n    spec:\n      containers:\n      - name: my-nginx\n        image: nginx\n        ports:\n        - containerPort: 80\nEOF",
      "terms": [
        {
          "term": "Deployment",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource for managing replicated applications"
        },
        {
          "term": "apiVersion",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the API version for the resource"
        },
        {
          "term": "apps/v1",
          "tier": 2,
          "reasoning": "Specific Kubernetes API group and version for workload resources like Deployments"
        },
        {
          "term": "kind",
          "tier": 2,
          "reasoning": "Kubernetes manifest field that specifies the type of resource being defined"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Kubernetes manifest section containing identifying information about the resource"
        },
        {
          "term": "name",
          "tier": 3,
          "reasoning": "Kubernetes metadata field used to identify resources within a namespace"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes manifest section defining the desired state specification of a resource"
        },
        {
          "term": "selector",
          "tier": 2,
          "reasoning": "Kubernetes field used to identify which Pods a controller should manage"
        },
        {
          "term": "matchLabels",
          "tier": 2,
          "reasoning": "Kubernetes selector type that matches resources based on exact label key-value pairs"
        },
        {
          "term": "replicas",
          "tier": 2,
          "reasoning": "Kubernetes Deployment field specifying the desired number of Pod instances"
        },
        {
          "term": "template",
          "tier": 2,
          "reasoning": "Kubernetes Pod template specification embedded within a Deployment"
        },
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Kubernetes metadata key-value pairs used for organizing and selecting resources"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Kubernetes Pod spec field defining the container(s) to run in the Pod"
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Core virtualization concept - isolated runtime environment for applications"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container image reference specifying the packaged application to run"
        },
        {
          "term": "nginx",
          "tier": 1,
          "reasoning": "Specific container image name - a well-known web server/reverse proxy"
        },
        {
          "term": "ports",
          "tier": 2,
          "reasoning": "Kubernetes container spec field defining network port configurations"
        },
        {
          "term": "containerPort",
          "tier": 2,
          "reasoning": "Kubernetes field specifying the port number exposed by a container"
        },
        {
          "term": "EOF",
          "tier": 3,
          "reasoning": "Shell heredoc delimiter used in bash/shell scripting for multi-line input"
        },
        {
          "term": "cat",
          "tier": 3,
          "reasoning": "Unix/Linux command used here to create a file from heredoc input"
        },
        {
          "term": "YAML",
          "tier": 3,
          "reasoning": "Data serialization format used for Kubernetes manifest files (implicit in deployment.yaml)"
        },
        {
          "term": "deployment.yaml",
          "tier": 3,
          "reasoning": "Kubernetes manifest file name following naming conventions for Deployment resources"
        },
        {
          "term": "my-nginx",
          "tier": 3,
          "reasoning": "Resource name and label value used to identify this specific Deployment and its Pods"
        },
        {
          "term": "run",
          "tier": 3,
          "reasoning": "Label key used in this manifest for Pod selection and identification"
        }
      ],
      "term_count": 24,
      "generated_at": "2026-02-08T21:05:21.485212",
      "elapsed_time": 14.211526870727539
    },
    {
      "chunk_id": "reference_node_node-status_sec3",
      "doc_id": "reference_node_node-status",
      "heading": "Conditions {#condition}",
      "source_file": "reference_node_node-status.md",
      "content": "The `conditions` field describes the status of all `Running` nodes. Examples of conditions include:\n\n{{< table caption = \"Node conditions, and a description of when each condition applies.\" >}}\n| Node Condition       | Description |\n|----------------------|-------------|\n| `Ready`              | `True` if the node is healthy and ready to accept pods, `False` if the node is not healthy and is not accepting pods, and `Unknown` if the node controller has not heard from the node in the last `node-monitor-grace-period` (default is 50 seconds) |\n| `DiskPressure`       | `True` if pressure exists on the disk size\u2014that is, if the disk capacity is low; otherwise `False` |\n| `MemoryPressure`     | `True` if pressure exists on the node memory\u2014that is, if the node memory is low; otherwise `False` |\n| `PIDPressure`        | `True` if pressure exists on the processes\u2014that is, if there are too many processes on the node; otherwise `False` |\n| `NetworkUnavailable` | `True` if the network for the node is not correctly configured, otherwise `False` |\n{{< /table >}}\n\n{{< note >}}\nIf you use command-line tools to print details of a cordoned Node, the Condition includes\n`SchedulingDisabled`. `SchedulingDisabled` is not a Condition in the Kubernetes API; instead,\ncordoned nodes are marked Unschedulable in their spec.\n{{< /note >}}\n\nIn the Kubernetes API, a node's condition is represented as part of the `.status`\nof the Node resource. For example, the following JSON structure describes a healthy node:\n\n```json\n\"conditions\": [\n  {\n    \"type\": \"Ready\",\n    \"status\": \"True\",\n    \"reason\": \"KubeletReady\",\n    \"message\": \"kubelet is posting ready status\",\n    \"lastHeartbeatTime\": \"2019-06-05T18:38:35Z\",\n    \"lastTransitionTime\": \"2019-06-05T11:41:27Z\"\n  }\n]\n```\n\nWhen problems occur on nodes, the Kubernetes control plane automatically creates\n[taints](/docs/concepts/scheduling-eviction/taint-and-toleration/) that match the conditions\naffecting the node. An example of this is when the `status` of the Ready condition\nremains `Unknown` or `False` for longer than the kube-controller-manager's `NodeMonitorGracePeriod`,\nwhich defaults to 50 seconds. This will cause either an `node.kubernetes.io/unreachable` taint, for an `Unknown` status,\nor a `node.kubernetes.io/not-ready` taint, for a `False` status, to be added to the Node.\n\nThese taints affect pending pods as the scheduler takes the Node's taints into consideration when\nassigning a pod to a Node. Existing pods scheduled to the node may be evicted due to the application\nof `NoExecute` taints. Pods may also have {{< glossary_tooltip text=\"tolerations\" term_id=\"toleration\" >}} that let\nthem schedule to and continue running on a Node even though it has a specific taint.\n\nSee [Taint Based Evictions](/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-based-evictions) and\n[Taint Nodes by Condition](/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition)\nfor more details.",
      "terms": [
        {
          "term": "conditions",
          "tier": 2,
          "reasoning": "Domain concept describing the status field of node resources in Kubernetes API"
        },
        {
          "term": "Running",
          "tier": 2,
          "reasoning": "Node status state indicating operational nodes"
        },
        {
          "term": "nodes",
          "tier": 2,
          "reasoning": "Core Kubernetes concept representing worker machines in a cluster"
        },
        {
          "term": "Node Condition",
          "tier": 2,
          "reasoning": "Specific Kubernetes concept for describing node health states"
        },
        {
          "term": "Ready",
          "tier": 1,
          "reasoning": "Named node condition type in Kubernetes API"
        },
        {
          "term": "DiskPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating low disk capacity"
        },
        {
          "term": "MemoryPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating low node memory"
        },
        {
          "term": "PIDPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating too many processes"
        },
        {
          "term": "NetworkUnavailable",
          "tier": 1,
          "reasoning": "Named node condition type indicating network misconfiguration"
        },
        {
          "term": "pods",
          "tier": 1,
          "reasoning": "Core Kubernetes API resource representing deployable units"
        },
        {
          "term": "node controller",
          "tier": 1,
          "reasoning": "Kubernetes control plane component managing node lifecycle"
        },
        {
          "term": "node-monitor-grace-period",
          "tier": 1,
          "reasoning": "Specific configuration parameter for node monitoring timeout"
        },
        {
          "term": "disk capacity",
          "tier": 3,
          "reasoning": "Technical term for storage space relevant to DiskPressure condition"
        },
        {
          "term": "node memory",
          "tier": 2,
          "reasoning": "Technical concept for memory resources on a node"
        },
        {
          "term": "processes",
          "tier": 3,
          "reasoning": "OS-level concept relevant to PIDPressure condition"
        },
        {
          "term": "network",
          "tier": 3,
          "reasoning": "Infrastructure concept relevant to NetworkUnavailable condition"
        },
        {
          "term": "cordoned Node",
          "tier": 2,
          "reasoning": "Kubernetes operational concept for nodes marked to prevent new pod scheduling"
        },
        {
          "term": "SchedulingDisabled",
          "tier": 1,
          "reasoning": "Condition label shown in CLI for cordoned nodes"
        },
        {
          "term": "Kubernetes API",
          "tier": 1,
          "reasoning": "Core interface for interacting with Kubernetes resources"
        },
        {
          "term": "Unschedulable",
          "tier": 2,
          "reasoning": "Node spec field marking nodes as unavailable for scheduling"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes resource specification field"
        },
        {
          "term": ".status",
          "tier": 2,
          "reasoning": "Kubernetes resource status field containing runtime state"
        },
        {
          "term": "Node resource",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a cluster node"
        },
        {
          "term": "type",
          "tier": 2,
          "reasoning": "Field in condition structure identifying the condition kind"
        },
        {
          "term": "status",
          "tier": 2,
          "reasoning": "Field in condition structure indicating True/False/Unknown state"
        },
        {
          "term": "reason",
          "tier": 2,
          "reasoning": "Field in condition structure providing machine-readable cause"
        },
        {
          "term": "message",
          "tier": 2,
          "reasoning": "Field in condition structure providing human-readable description"
        },
        {
          "term": "lastHeartbeatTime",
          "tier": 2,
          "reasoning": "Condition field tracking last node heartbeat timestamp"
        },
        {
          "term": "lastTransitionTime",
          "tier": 2,
          "reasoning": "Condition field tracking when condition last changed"
        },
        {
          "term": "KubeletReady",
          "tier": 1,
          "reasoning": "Specific reason value indicating kubelet is operational"
        },
        {
          "term": "kubelet",
          "tier": 1,
          "reasoning": "Core Kubernetes node agent component"
        },
        {
          "term": "control plane",
          "tier": 2,
          "reasoning": "Kubernetes architectural concept for cluster management components"
        },
        {
          "term": "taints",
          "tier": 2,
          "reasoning": "Kubernetes scheduling mechanism to repel pods from nodes"
        },
        {
          "term": "kube-controller-manager",
          "tier": 1,
          "reasoning": "Core Kubernetes control plane component running controllers"
        },
        {
          "term": "NodeMonitorGracePeriod",
          "tier": 1,
          "reasoning": "Specific kube-controller-manager configuration parameter"
        },
        {
          "term": "node.kubernetes.io/unreachable",
          "tier": 1,
          "reasoning": "Specific taint key applied when node status is Unknown"
        },
        {
          "term": "node.kubernetes.io/not-ready",
          "tier": 1,
          "reasoning": "Specific taint key applied when node status is False"
        },
        {
          "term": "Unknown",
          "tier": 2,
          "reasoning": "Condition status value indicating uncertain node state"
        },
        {
          "term": "False",
          "tier": 2,
          "reasoning": "Condition status value indicating negative/unhealthy state"
        },
        {
          "term": "True",
          "tier": 2,
          "reasoning": "Condition status value indicating positive/healthy state"
        },
        {
          "term": "pending pods",
          "tier": 2,
          "reasoning": "Pods waiting to be scheduled to a node"
        },
        {
          "term": "scheduler",
          "tier": 1,
          "reasoning": "Kubernetes control plane component assigning pods to nodes"
        },
        {
          "term": "evicted",
          "tier": 2,
          "reasoning": "Process of removing pods from nodes"
        },
        {
          "term": "NoExecute",
          "tier": 1,
          "reasoning": "Taint effect that evicts existing pods and prevents new scheduling"
        },
        {
          "term": "tolerations",
          "tier": 2,
          "reasoning": "Pod specification allowing scheduling on tainted nodes"
        },
        {
          "term": "toleration",
          "tier": 2,
          "reasoning": "Singular form of tolerations concept"
        },
        {
          "term": "taint",
          "tier": 2,
          "reasoning": "Singular form of taints scheduling mechanism"
        },
        {
          "term": "Taint Based Evictions",
          "tier": 2,
          "reasoning": "Kubernetes concept for evicting pods based on node taints"
        },
        {
          "term": "Taint Nodes by Condition",
          "tier": 2,
          "reasoning": "Kubernetes feature automatically tainting nodes based on conditions"
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Core Kubernetes process of assigning pods to nodes"
        }
      ],
      "term_count": 50,
      "generated_at": "2026-02-08T21:05:46.314521",
      "elapsed_time": 23.823687314987183
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec21",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`ProviderConfiguration`     {#apiserver-config-k8s-io-v1-ProviderConfiguration}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [ResourceConfiguration](#apiserver-config-k8s-io-v1-ResourceConfiguration)\n\n\n<p>ProviderConfiguration stores the provided configuration for an encryption provider.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>aesgcm</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-AESConfiguration\"><code>AESConfiguration</code></a>\n</td>\n<td>\n   <p>aesgcm is the configuration for the AES-GCM transformer.</p>\n</td>\n</tr>\n<tr><td><code>aescbc</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-AESConfiguration\"><code>AESConfiguration</code></a>\n</td>\n<td>\n   <p>aescbc is the configuration for the AES-CBC transformer.</p>\n</td>\n</tr>\n<tr><td><code>secretbox</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-SecretboxConfiguration\"><code>SecretboxConfiguration</code></a>\n</td>\n<td>\n   <p>secretbox is the configuration for the Secretbox based transformer.</p>\n</td>\n</tr>\n<tr><td><code>identity</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-IdentityConfiguration\"><code>IdentityConfiguration</code></a>\n</td>\n<td>\n   <p>identity is the (empty) configuration for the identity transformer.</p>\n</td>\n</tr>\n<tr><td><code>kms</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-KMSConfiguration\"><code>KMSConfiguration</code></a>\n</td>\n<td>\n   <p>kms contains the name, cache size and path to configuration file for a KMS based envelope transformer.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "ResourceConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for resource settings."
        },
        {
          "term": "ProviderConfiguration",
          "tier": 1,
          "reasoning": "Named configuration structure that stores encryption provider settings."
        },
        {
          "term": "AESConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for AES-based encryption transformers."
        },
        {
          "term": "SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for Secretbox-based encryption transformer."
        },
        {
          "term": "IdentityConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for the identity transformer."
        },
        {
          "term": "KMSConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for KMS-based envelope transformer."
        },
        {
          "term": "encryption provider",
          "tier": 2,
          "reasoning": "Domain concept referring to a component that provides encryption capabilities."
        },
        {
          "term": "aesgcm",
          "tier": 2,
          "reasoning": "Configuration field name for AES-GCM transformer, a specific encryption mode."
        },
        {
          "term": "AES-GCM transformer",
          "tier": 2,
          "reasoning": "Encryption component using AES in Galois/Counter Mode for data transformation."
        },
        {
          "term": "aescbc",
          "tier": 2,
          "reasoning": "Configuration field name for AES-CBC transformer, a specific encryption mode."
        },
        {
          "term": "AES-CBC transformer",
          "tier": 2,
          "reasoning": "Encryption component using AES in Cipher Block Chaining mode for data transformation."
        },
        {
          "term": "secretbox",
          "tier": 2,
          "reasoning": "Configuration field for Secretbox-based encryption transformer."
        },
        {
          "term": "Secretbox based transformer",
          "tier": 2,
          "reasoning": "Encryption component using NaCl Secretbox for authenticated encryption."
        },
        {
          "term": "identity",
          "tier": 2,
          "reasoning": "Configuration field for identity transformer that performs no encryption."
        },
        {
          "term": "identity transformer",
          "tier": 2,
          "reasoning": "A transformer that passes data through unchanged without encryption."
        },
        {
          "term": "kms",
          "tier": 2,
          "reasoning": "Configuration field for Key Management Service based encryption."
        },
        {
          "term": "KMS based envelope transformer",
          "tier": 2,
          "reasoning": "Encryption component using external KMS for envelope encryption."
        },
        {
          "term": "envelope transformer",
          "tier": 2,
          "reasoning": "Encryption pattern where data encryption keys are wrapped by a master key."
        },
        {
          "term": "transformer",
          "tier": 2,
          "reasoning": "Domain concept for components that transform/encrypt data at rest."
        },
        {
          "term": "cache size",
          "tier": 3,
          "reasoning": "Technical parameter for KMS configuration affecting performance."
        },
        {
          "term": "configuration file",
          "tier": 3,
          "reasoning": "Technical term for file containing KMS transformer settings."
        },
        {
          "term": "apiserver-config-k8s-io-v1",
          "tier": 1,
          "reasoning": "API group and version identifier for Kubernetes API server configuration."
        },
        {
          "term": "AES-GCM",
          "tier": 3,
          "reasoning": "Advanced Encryption Standard in Galois/Counter Mode, a cryptographic algorithm."
        },
        {
          "term": "AES-CBC",
          "tier": 3,
          "reasoning": "Advanced Encryption Standard in Cipher Block Chaining mode, a cryptographic algorithm."
        },
        {
          "term": "KMS",
          "tier": 2,
          "reasoning": "Key Management Service, external service for managing encryption keys."
        }
      ],
      "term_count": 25,
      "generated_at": "2026-02-08T21:05:59.136387",
      "elapsed_time": 11.813421964645386
    },
    {
      "chunk_id": "reference_setup-tools_kubeadm_kubeadm-upgrade_sec1",
      "doc_id": "reference_setup-tools_kubeadm_kubeadm-upgrade",
      "heading": "kubeadm upgrade guidance",
      "source_file": "reference_setup-tools_kubeadm_kubeadm-upgrade.md",
      "content": "The steps for performing an upgrade using kubeadm are outlined in [this document](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/).\nFor older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.\n\nYou can use `kubeadm upgrade diff` to see the changes that would be applied to static pod manifests.\n\nIn Kubernetes v1.15.0 and later, `kubeadm upgrade apply` and `kubeadm upgrade node` will also\nautomatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.\nTo opt-out, it is possible to pass the flag `--certificate-renewal=false`. For more details about certificate\nrenewal see the [certificate management documentation](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs).\n\n{{< note >}}\nThe commands `kubeadm upgrade apply` and `kubeadm upgrade plan` have a legacy `--config`\nflag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular\ncontrol-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are\nreports of unexpected results.\n{{</ note >}}",
      "terms": [
        {
          "term": "kubeadm",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI tool for cluster bootstrapping and management"
        },
        {
          "term": "kubeadm upgrade",
          "tier": 1,
          "reasoning": "Specific kubeadm subcommand for performing cluster upgrades"
        },
        {
          "term": "kubeadm upgrade diff",
          "tier": 1,
          "reasoning": "Specific kubeadm command to preview changes to static pod manifests"
        },
        {
          "term": "kubeadm upgrade apply",
          "tier": 1,
          "reasoning": "Specific kubeadm command to apply cluster upgrades"
        },
        {
          "term": "kubeadm upgrade node",
          "tier": 1,
          "reasoning": "Specific kubeadm command to upgrade a node"
        },
        {
          "term": "kubeadm upgrade plan",
          "tier": 1,
          "reasoning": "Specific kubeadm command for planning cluster upgrades"
        },
        {
          "term": "static pod manifests",
          "tier": 2,
          "reasoning": "Domain concept referring to pod definitions managed directly by kubelet"
        },
        {
          "term": "static pod",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for pods managed directly by kubelet without API server"
        },
        {
          "term": "manifests",
          "tier": 2,
          "reasoning": "Technical term for Kubernetes resource definition files"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform being documented"
        },
        {
          "term": "certificates",
          "tier": 2,
          "reasoning": "Security concept for TLS/PKI certificates used in cluster authentication"
        },
        {
          "term": "certificate renewal",
          "tier": 2,
          "reasoning": "Process of renewing expiring certificates in the cluster"
        },
        {
          "term": "kubeconfig files",
          "tier": 1,
          "reasoning": "Configuration files containing cluster access credentials and settings"
        },
        {
          "term": "kubeconfig",
          "tier": 1,
          "reasoning": "Core Kubernetes configuration file format for cluster access"
        },
        {
          "term": "node",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept representing a worker machine in the cluster"
        },
        {
          "term": "--certificate-renewal=false",
          "tier": 1,
          "reasoning": "Specific CLI flag to disable automatic certificate renewal"
        },
        {
          "term": "--config",
          "tier": 1,
          "reasoning": "CLI flag for specifying configuration during upgrade operations"
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Core architectural concept representing a set of Kubernetes nodes"
        },
        {
          "term": "control-plane node",
          "tier": 2,
          "reasoning": "Node running control plane components that manage the cluster"
        },
        {
          "term": "control-plane",
          "tier": 2,
          "reasoning": "Architectural concept for the management layer of Kubernetes"
        },
        {
          "term": "upgrade",
          "tier": 2,
          "reasoning": "Technical process of updating Kubernetes version or components"
        },
        {
          "term": "upgrade workflow",
          "tier": 2,
          "reasoning": "The defined process and steps for performing cluster upgrades"
        },
        {
          "term": "reconfigure",
          "tier": 2,
          "reasoning": "Technical operation of changing cluster configuration"
        },
        {
          "term": "certificate management",
          "tier": 2,
          "reasoning": "Domain concept for handling PKI certificates in the cluster"
        },
        {
          "term": "v1.15.0",
          "tier": 3,
          "reasoning": "Specific Kubernetes version reference indicating feature availability"
        },
        {
          "term": "flag",
          "tier": 3,
          "reasoning": "Technical term for command-line options passed to CLI tools"
        }
      ],
      "term_count": 26,
      "generated_at": "2026-02-08T21:06:14.238454",
      "elapsed_time": 14.094237565994263
    },
    {
      "chunk_id": "tasks_configure-pod-container_configure-pod-configmap_sec18",
      "doc_id": "tasks_configure-pod-container_configure-pod-configmap",
      "heading": "{{% heading \"cleanup\" %}}",
      "source_file": "tasks_configure-pod-container_configure-pod-configmap.md",
      "content": "Delete the ConfigMaps and Pods that you made:\n\n```bash\nkubectl delete configmaps/game-config configmaps/game-config-2 configmaps/game-config-3 \\\n               configmaps/game-config-env-file\nkubectl delete pod dapi-test-pod --now",
      "terms": [
        {
          "term": "ConfigMaps",
          "tier": 1,
          "reasoning": "Kubernetes API object for storing configuration data as key-value pairs, explicitly named in the delete command."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Core Kubernetes API object representing the smallest deployable unit, explicitly mentioned in the section header."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool used to interact with the cluster, shown executing delete commands."
        },
        {
          "term": "kubectl delete",
          "tier": 1,
          "reasoning": "Specific kubectl subcommand for removing Kubernetes resources from the cluster."
        },
        {
          "term": "configmaps/game-config",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference using type/name notation in kubectl command."
        },
        {
          "term": "configmaps/game-config-2",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference demonstrating multiple resource deletion."
        },
        {
          "term": "configmaps/game-config-3",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference in the batch delete operation."
        },
        {
          "term": "configmaps/game-config-env-file",
          "tier": 1,
          "reasoning": "ConfigMap resource created from environment file, indicated by naming convention."
        },
        {
          "term": "pod",
          "tier": 1,
          "reasoning": "Kubernetes resource type specified in the delete command for dapi-test-pod."
        },
        {
          "term": "dapi-test-pod",
          "tier": 1,
          "reasoning": "Specific named Pod resource being deleted, likely used for Downward API testing based on naming."
        },
        {
          "term": "delete",
          "tier": 2,
          "reasoning": "Kubernetes operation for removing resources from the cluster, core lifecycle management concept."
        },
        {
          "term": "--now",
          "tier": 2,
          "reasoning": "kubectl flag that forces immediate deletion by setting grace period to zero, bypassing graceful termination."
        },
        {
          "term": "bash",
          "tier": 3,
          "reasoning": "Shell environment indicated by the code block annotation, context for command execution."
        },
        {
          "term": "game-config",
          "tier": 2,
          "reasoning": "ConfigMap name pattern used in the example, representing application configuration resource."
        },
        {
          "term": "env-file",
          "tier": 2,
          "reasoning": "Configuration pattern indicated in resource name, referring to environment file-based ConfigMap creation."
        }
      ],
      "term_count": 15,
      "generated_at": "2026-02-08T21:06:25.429999",
      "elapsed_time": 10.18539571762085
    }
  ],
  "chunks": [
    {
      "chunk_id": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions_sec0",
      "doc_id": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions",
      "heading": "Introduction",
      "source_file": "tasks_extend-kubernetes_custom-resources_custom-resource-definitions.md",
      "content": "---\ntitle: Extend the Kubernetes API with CustomResourceDefinitions\nreviewers:\n- deads2k\n- jpbetz\n- liggitt\n- roycaihw\n- sttts\ncontent_type: task\nmin-kubernetes-server-version: 1.16\nweight: 20\n---\n\n<!-- overview -->\nThis page shows how to install a\n[custom resource](/docs/concepts/extend-kubernetes/api-extension/custom-resources/)\ninto the Kubernetes API by creating a\n[CustomResourceDefinition](/docs/reference/generated/kubernetes-api/{{< param \"version\" >}}/#customresourcedefinition-v1-apiextensions-k8s-io).",
      "terms": [
        {
          "term": "Kubernetes API",
          "tier": 1,
          "reasoning": "Core Kubernetes component that serves as the primary interface for cluster operations and resource management."
        },
        {
          "term": "CustomResourceDefinitions",
          "tier": 1,
          "reasoning": "Named Kubernetes API object used to extend the API with custom resources."
        },
        {
          "term": "CustomResourceDefinition",
          "tier": 1,
          "reasoning": "Singular form of the API object that defines custom resources in Kubernetes."
        },
        {
          "term": "custom resource",
          "tier": 2,
          "reasoning": "Domain concept referring to user-defined extensions to the Kubernetes API."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "General technical term for Application Programming Interface, contextually important for Kubernetes extension."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform that is the subject of this documentation."
        },
        {
          "term": "API extension",
          "tier": 2,
          "reasoning": "Domain concept describing the process of extending Kubernetes API capabilities."
        },
        {
          "term": "min-kubernetes-server-version",
          "tier": 3,
          "reasoning": "Metadata field indicating minimum Kubernetes version requirement for the feature."
        },
        {
          "term": "1.16",
          "tier": 3,
          "reasoning": "Specific Kubernetes version number referenced as minimum server version."
        },
        {
          "term": "apiextensions-k8s-io",
          "tier": 1,
          "reasoning": "Kubernetes API group that contains the CustomResourceDefinition resource."
        },
        {
          "term": "v1",
          "tier": 3,
          "reasoning": "API version indicator denoting stable API version in Kubernetes."
        }
      ],
      "term_count": 11,
      "generated_at": "2026-02-08T17:48:26.027045",
      "elapsed_time": 7.632281541824341
    },
    {
      "chunk_id": "concepts_workloads_management_sec10",
      "doc_id": "concepts_workloads_management",
      "heading": "In-place updates of resources",
      "source_file": "concepts_workloads_management.md",
      "content": "Sometimes it's necessary to make narrow, non-disruptive updates to resources you've created.\n\n### kubectl apply\n\nIt is suggested to maintain a set of configuration files in source control\n(see [configuration as code](https://martinfowler.com/bliki/InfrastructureAsCode.html)),\nso that they can be maintained and versioned along with the code for the resources they configure.\nThen, you can use [`kubectl apply`](/docs/reference/kubectl/generated/kubectl_apply/)\nto push your configuration changes to the cluster.\n\nThis command will compare the version of the configuration that you're pushing with the previous\nversion and apply the changes you've made, without overwriting any automated changes to properties\nyou haven't specified.\n\n```shell\nkubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml\n```\n\n```none\ndeployment.apps/my-nginx configured\n```\n\nTo learn more about the underlying mechanism, read [server-side apply](/docs/reference/using-api/server-side-apply/).\n\n### kubectl edit\n\nAlternatively, you may also update resources with [`kubectl edit`](/docs/reference/kubectl/generated/kubectl_edit/):\n\n```shell\nkubectl edit deployment/my-nginx\n```\n\nThis is equivalent to first `get` the resource, edit it in text editor, and then `apply` the\nresource with the updated version:\n\n```shell\nkubectl get deployment my-nginx -o yaml > /tmp/nginx.yaml\nvi /tmp/nginx.yaml",
      "terms": [
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command for applying configuration changes to cluster resources."
        },
        {
          "term": "kubectl edit",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command for editing resources directly."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "The official Kubernetes command-line tool referenced throughout the documentation."
        },
        {
          "term": "deployment",
          "tier": 1,
          "reasoning": "Kubernetes API object/resource type shown in examples (deployment.apps/my-nginx, deployment/my-nginx)."
        },
        {
          "term": "my-nginx",
          "tier": 1,
          "reasoning": "Specific named deployment resource used in the examples."
        },
        {
          "term": "nginx-deployment.yaml",
          "tier": 1,
          "reasoning": "Specific configuration file name referenced in the kubectl apply example."
        },
        {
          "term": "deployment.apps",
          "tier": 1,
          "reasoning": "Kubernetes API group and resource type shown in command output."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Domain concept referring to Kubernetes API objects that can be created and managed."
        },
        {
          "term": "configuration files",
          "tier": 2,
          "reasoning": "Technical concept referring to files that define Kubernetes resource specifications."
        },
        {
          "term": "source control",
          "tier": 2,
          "reasoning": "Technical concept for version control systems used to manage configuration."
        },
        {
          "term": "configuration as code",
          "tier": 2,
          "reasoning": "Infrastructure/DevOps concept explicitly referenced with link to Martin Fowler's definition."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Core Kubernetes architectural concept referring to the set of nodes running containerized applications."
        },
        {
          "term": "configuration changes",
          "tier": 2,
          "reasoning": "Domain concept describing modifications to resource specifications."
        },
        {
          "term": "server-side apply",
          "tier": 2,
          "reasoning": "Kubernetes-specific mechanism for applying configuration changes mentioned as underlying mechanism."
        },
        {
          "term": "automated changes",
          "tier": 2,
          "reasoning": "Concept referring to system-generated modifications to resource properties."
        },
        {
          "term": "properties",
          "tier": 2,
          "reasoning": "Technical term referring to resource specification fields/attributes."
        },
        {
          "term": "text editor",
          "tier": 3,
          "reasoning": "General technical tool referenced in the kubectl edit workflow."
        },
        {
          "term": "yaml",
          "tier": 3,
          "reasoning": "Data serialization format used for Kubernetes configuration files, shown in -o yaml flag."
        },
        {
          "term": "-o yaml",
          "tier": 2,
          "reasoning": "kubectl output format flag for retrieving resources in YAML format."
        },
        {
          "term": "get",
          "tier": 2,
          "reasoning": "kubectl subcommand operation for retrieving resources, referenced in workflow description."
        },
        {
          "term": "kubectl get",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI command shown explicitly in the example."
        },
        {
          "term": "apply",
          "tier": 2,
          "reasoning": "Kubernetes operation for pushing configuration to cluster, used both as command and verb."
        },
        {
          "term": "version",
          "tier": 3,
          "reasoning": "Technical concept referring to configuration state comparison in apply operation."
        },
        {
          "term": "versioned",
          "tier": 3,
          "reasoning": "Technical concept describing configuration files maintained with version history."
        }
      ],
      "term_count": 24,
      "generated_at": "2026-02-08T17:48:41.104171",
      "elapsed_time": 14.076469421386719
    },
    {
      "chunk_id": "concepts_extend-kubernetes_operator_sec7",
      "doc_id": "concepts_extend-kubernetes_operator",
      "heading": "{{% heading \"whatsnext\" %}}",
      "source_file": "concepts_extend-kubernetes_operator.md",
      "content": "* Read the {{< glossary_tooltip text=\"CNCF\" term_id=\"cncf\" >}}\n  [Operator White Paper](https://github.com/cncf/tag-app-delivery/blob/163962c4b1cd70d085107fc579e3e04c2e14d59c/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md).\n* Learn more about [Custom Resources](/docs/concepts/extend-kubernetes/api-extension/custom-resources/)\n* Find ready-made operators on [OperatorHub.io](https://operatorhub.io/) to suit your use case\n* [Publish](https://operatorhub.io/) your operator for other people to use\n* Read [CoreOS' original article](https://web.archive.org/web/20170129131616/https://coreos.com/blog/introducing-operators.html)\n  that introduced the operator pattern (this is an archived version of the original article).\n* Read an [article](https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps)\n  from Google Cloud about best practices for building operators",
      "terms": [
        {
          "term": "CNCF",
          "tier": 1,
          "reasoning": "Cloud Native Computing Foundation - a specific organization and proper noun in the cloud-native ecosystem"
        },
        {
          "term": "Operator",
          "tier": 1,
          "reasoning": "A Kubernetes-specific pattern and resource type for managing applications"
        },
        {
          "term": "operator",
          "tier": 1,
          "reasoning": "Appears in lowercase form throughout the text referring to the Kubernetes operator pattern"
        },
        {
          "term": "operators",
          "tier": 1,
          "reasoning": "Plural form of the Kubernetes operator resource/pattern"
        },
        {
          "term": "Custom Resources",
          "tier": 1,
          "reasoning": "A specific Kubernetes API extension mechanism for defining custom API objects"
        },
        {
          "term": "OperatorHub.io",
          "tier": 1,
          "reasoning": "A specific platform/registry for discovering and publishing Kubernetes operators"
        },
        {
          "term": "CoreOS",
          "tier": 1,
          "reasoning": "A specific company/project that originally introduced the operator pattern"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the core subject of this documentation"
        },
        {
          "term": "operator pattern",
          "tier": 2,
          "reasoning": "A specific architectural pattern in Kubernetes for automating application management"
        },
        {
          "term": "stateful apps",
          "tier": 2,
          "reasoning": "A category of applications that maintain persistent state, relevant to operator use cases"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Fundamental compute abstraction in Kubernetes and cloud-native computing"
        },
        {
          "term": "White Paper",
          "tier": 3,
          "reasoning": "Technical document type referenced for operator specifications"
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "Application Programming Interface - referenced in context of Kubernetes API extension"
        },
        {
          "term": "best practices",
          "tier": 3,
          "reasoning": "Technical guidance term used in context of building operators"
        },
        {
          "term": "Google Cloud",
          "tier": 1,
          "reasoning": "A specific cloud provider platform mentioned as source of operator guidance"
        },
        {
          "term": "use case",
          "tier": 3,
          "reasoning": "Technical term describing specific application scenarios for operators"
        }
      ],
      "term_count": 16,
      "generated_at": "2026-02-08T17:48:51.453774",
      "elapsed_time": 9.34868836402893
    },
    {
      "chunk_id": "reference_glossary_sysctl_sec0",
      "doc_id": "reference_glossary_sysctl",
      "heading": "Introduction",
      "source_file": "reference_glossary_sysctl.md",
      "content": "---\ntitle: sysctl\nid: sysctl\ndate: 2019-02-12\nfull_link: /docs/tasks/administer-cluster/sysctl-cluster/\nshort_description: >\n  An interface for getting and setting Unix kernel parameters\n\naka:\ntags:\n- tool\n---\n `sysctl` is a semi-standardized interface for reading or changing the\n attributes of the running Unix kernel.\n\n<!--more-->\n\nOn Unix-like systems, `sysctl` is both the name of the tool that administrators\nuse to view and modify these settings, and also the system call that the tool\nuses.\n\n{{< glossary_tooltip text=\"Container\" term_id=\"container\" >}} runtimes and\nnetwork plugins may rely on `sysctl` values being set a certain way.",
      "terms": [
        {
          "term": "sysctl",
          "tier": 1,
          "reasoning": "Named Unix tool and system call for kernel parameter management, the primary subject of this documentation."
        },
        {
          "term": "Unix kernel",
          "tier": 2,
          "reasoning": "Core operating system component whose parameters sysctl manages."
        },
        {
          "term": "kernel parameters",
          "tier": 2,
          "reasoning": "Technical concept referring to configurable settings of the Unix kernel."
        },
        {
          "term": "Unix kernel parameters",
          "tier": 2,
          "reasoning": "Compound term describing the specific settings that sysctl reads and modifies."
        },
        {
          "term": "Unix-like systems",
          "tier": 3,
          "reasoning": "Category of operating systems where sysctl operates."
        },
        {
          "term": "system call",
          "tier": 2,
          "reasoning": "Technical concept describing the programmatic interface sysctl uses to interact with the kernel."
        },
        {
          "term": "Container",
          "tier": 2,
          "reasoning": "Core Kubernetes/infrastructure concept; container runtimes depend on sysctl values."
        },
        {
          "term": "network plugins",
          "tier": 2,
          "reasoning": "Infrastructure components that handle networking and may depend on sysctl values."
        },
        {
          "term": "interface",
          "tier": 3,
          "reasoning": "Technical term describing sysctl's role as a standardized access method."
        },
        {
          "term": "attributes",
          "tier": 3,
          "reasoning": "Technical term referring to the kernel properties that can be viewed or modified."
        },
        {
          "term": "running",
          "tier": 3,
          "reasoning": "Technical context indicating the kernel is active/executing when sysctl operates on it."
        },
        {
          "term": "semi-standardized",
          "tier": 3,
          "reasoning": "Technical descriptor indicating sysctl's partial standardization across Unix systems."
        },
        {
          "term": "tool",
          "tier": 3,
          "reasoning": "Explicitly tagged category for sysctl in the metadata."
        }
      ],
      "term_count": 13,
      "generated_at": "2026-02-08T21:00:29.566942",
      "elapsed_time": 11.349516868591309
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1beta1_sec18",
      "doc_id": "reference_config-api_apiserver-config.v1beta1",
      "heading": "`TCPTransport`     {#apiserver-k8s-io-v1beta1-TCPTransport}",
      "source_file": "reference_config-api_apiserver-config.v1beta1.md",
      "content": "**Appears in:**\n\n- [Transport](#apiserver-k8s-io-v1beta1-Transport)\n\n\n<p>TCPTransport provides the information to connect to konnectivity server via TCP</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>url</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>URL is the location of the konnectivity server to connect to.\nAs an example it might be &quot;https://127.0.0.1:8131&quot;</p>\n</td>\n</tr>\n<tr><td><code>tlsConfig</code><br/>\n<a href=\"#apiserver-k8s-io-v1beta1-TLSConfig\"><code>TLSConfig</code></a>\n</td>\n<td>\n   <p>TLSConfig is the config needed to use TLS when connecting to konnectivity server</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "Transport",
          "tier": 1,
          "reasoning": "Kubernetes API object type referenced in the documentation for network transport configuration."
        },
        {
          "term": "TCPTransport",
          "tier": 1,
          "reasoning": "Specific Kubernetes API resource type that provides TCP connection configuration to konnectivity server."
        },
        {
          "term": "konnectivity server",
          "tier": 1,
          "reasoning": "Named Kubernetes infrastructure component for network connectivity between control plane and nodes."
        },
        {
          "term": "TLSConfig",
          "tier": 1,
          "reasoning": "Kubernetes API object type for TLS configuration settings."
        },
        {
          "term": "apiserver-k8s-io-v1beta1-Transport",
          "tier": 1,
          "reasoning": "Specific API version and group reference for the Transport resource."
        },
        {
          "term": "apiserver-k8s-io-v1beta1-TLSConfig",
          "tier": 1,
          "reasoning": "Specific API version and group reference for the TLSConfig resource."
        },
        {
          "term": "TCP",
          "tier": 2,
          "reasoning": "Network protocol used for transport layer communication to konnectivity server."
        },
        {
          "term": "TLS",
          "tier": 2,
          "reasoning": "Transport Layer Security protocol for encrypted connections to konnectivity server."
        },
        {
          "term": "url",
          "tier": 3,
          "reasoning": "Configuration field specifying the location/address of the konnectivity server."
        },
        {
          "term": "tlsConfig",
          "tier": 2,
          "reasoning": "Configuration field name for TLS settings when connecting to konnectivity server."
        },
        {
          "term": "v1beta1",
          "tier": 2,
          "reasoning": "API version indicating beta maturity level of the Kubernetes API."
        },
        {
          "term": "https",
          "tier": 3,
          "reasoning": "Secure HTTP protocol shown in the example URL for konnectivity server connection."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term describing configuration parameters in the API object specification."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the url field in the API object."
        },
        {
          "term": "connect",
          "tier": 3,
          "reasoning": "Technical action describing establishing network connection to konnectivity server."
        }
      ],
      "term_count": 15,
      "generated_at": "2026-02-08T21:00:41.095446",
      "elapsed_time": 10.527211666107178
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec24",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`UserValidationRule`     {#apiserver-config-k8s-io-v1-UserValidationRule}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [JWTAuthenticator](#apiserver-config-k8s-io-v1-JWTAuthenticator)\n\n\n<p>UserValidationRule provides the configuration for a single user info validation rule.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>expression</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>expression represents the expression which will be evaluated by CEL.\nMust return true for the validation to pass.</p>\n<p>CEL expressions have access to the contents of UserInfo, organized into CEL variable:</p>\n<ul>\n<li>'user' - authentication.k8s.io/v1, Kind=UserInfo object\nRefer to https://github.com/kubernetes/api/blob/release-1.28/authentication/v1/types.go#L105-L122 for the definition.\nAPI documentation: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#userinfo-v1-authentication-k8s-io</li>\n</ul>\n<p>Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/</p>\n</td>\n</tr>\n<tr><td><code>message</code><br/>\n<code>string</code>\n</td>\n<td>\n   <p>message customizes the returned error message when rule returns false.\nmessage is a literal string.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "JWTAuthenticator",
          "tier": 1,
          "reasoning": "Named Kubernetes API object for JWT-based authentication configuration."
        },
        {
          "term": "UserValidationRule",
          "tier": 1,
          "reasoning": "Named configuration object that defines user info validation rules."
        },
        {
          "term": "UserInfo",
          "tier": 1,
          "reasoning": "Named Kubernetes API object (authentication.k8s.io/v1) containing user identity information."
        },
        {
          "term": "CEL",
          "tier": 2,
          "reasoning": "Common Expression Language - a domain-specific language used for validation expressions in Kubernetes."
        },
        {
          "term": "expression",
          "tier": 2,
          "reasoning": "Technical field name representing the CEL expression to be evaluated for validation."
        },
        {
          "term": "validation",
          "tier": 2,
          "reasoning": "Domain concept referring to the process of verifying user information meets specified rules."
        },
        {
          "term": "authentication",
          "tier": 2,
          "reasoning": "Security domain concept for verifying user identity, referenced in API group path."
        },
        {
          "term": "authentication.k8s.io/v1",
          "tier": 1,
          "reasoning": "Kubernetes API group and version for authentication-related resources."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "Application Programming Interface - general technical term used in context of Kubernetes API."
        },
        {
          "term": "CEL variable",
          "tier": 2,
          "reasoning": "Technical concept referring to variables accessible within CEL expressions."
        },
        {
          "term": "CEL expressions",
          "tier": 2,
          "reasoning": "Technical term for expressions written in Common Expression Language for validation logic."
        },
        {
          "term": "user",
          "tier": 2,
          "reasoning": "CEL variable name providing access to UserInfo object in validation expressions."
        },
        {
          "term": "message",
          "tier": 2,
          "reasoning": "Configuration field for customizing error messages when validation rules fail."
        },
        {
          "term": "error message",
          "tier": 3,
          "reasoning": "Technical term for the message returned when validation fails."
        },
        {
          "term": "literal string",
          "tier": 3,
          "reasoning": "Technical term describing the type of value expected for the message field."
        },
        {
          "term": "rule",
          "tier": 2,
          "reasoning": "Domain concept referring to a single validation condition to be evaluated."
        },
        {
          "term": "Kind",
          "tier": 2,
          "reasoning": "Kubernetes API concept identifying the type of resource object."
        },
        {
          "term": "object",
          "tier": 3,
          "reasoning": "Technical term referring to Kubernetes API resource instances."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for configuration fields."
        },
        {
          "term": "Field",
          "tier": 2,
          "reasoning": "Technical term for configuration parameters in Kubernetes API objects."
        },
        {
          "term": "kubernetes-api",
          "tier": 1,
          "reasoning": "Reference to the Kubernetes API documentation and specification."
        },
        {
          "term": "release-1.28",
          "tier": 2,
          "reasoning": "Kubernetes version reference indicating API compatibility."
        },
        {
          "term": "v1.28",
          "tier": 2,
          "reasoning": "Kubernetes version identifier referenced in documentation links."
        }
      ],
      "term_count": 23,
      "generated_at": "2026-02-08T21:00:55.900069",
      "elapsed_time": 13.80327320098877
    },
    {
      "chunk_id": "reference_access-authn-authz_validating-admission-policy_sec0",
      "doc_id": "reference_access-authn-authz_validating-admission-policy",
      "heading": "Introduction",
      "source_file": "reference_access-authn-authz_validating-admission-policy.md",
      "content": "---\nreviewers:\n- liggitt\n- jpbetz\n- cici37\ntitle: Validating Admission Policy\ncontent_type: concept\n---\n\n<!-- overview -->\n\n{{< feature-state state=\"stable\" for_k8s_version=\"v1.30\" >}}\n\nThis page provides an overview of Validating Admission Policy.\n\n\n<!-- body -->",
      "terms": [
        {
          "term": "Validating Admission Policy",
          "tier": 1,
          "reasoning": "Core Kubernetes API resource and the primary subject of this documentation page."
        },
        {
          "term": "Admission Policy",
          "tier": 2,
          "reasoning": "Domain concept referring to policies that control admission of resources to the cluster."
        },
        {
          "term": "stable",
          "tier": 3,
          "reasoning": "Feature lifecycle stage indicating the feature has reached production-ready status in Kubernetes."
        },
        {
          "term": "v1.30",
          "tier": 3,
          "reasoning": "Specific Kubernetes version identifier indicating when the feature became stable."
        },
        {
          "term": "feature-state",
          "tier": 3,
          "reasoning": "Kubernetes documentation concept indicating the maturity level of a feature."
        },
        {
          "term": "admission",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to the process of validating and mutating API requests before persistence."
        }
      ],
      "term_count": 6,
      "generated_at": "2026-02-08T21:01:01.809018",
      "elapsed_time": 4.907103776931763
    },
    {
      "chunk_id": "concepts_workloads_management_sec0",
      "doc_id": "concepts_workloads_management",
      "heading": "Introduction",
      "source_file": "concepts_workloads_management.md",
      "content": "---\ntitle: Managing Workloads\ncontent_type: concept\nreviewers:\n- janetkuo\nweight: 40\n---\n\n<!-- overview -->\n\nYou've deployed your application and exposed it via a Service. Now what? Kubernetes provides a\nnumber of tools to help you manage your application deployment, including scaling and updating.\n\n<!-- body -->",
      "terms": [
        {
          "term": "Workloads",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to applications running on the cluster, appears in title as domain-specific term"
        },
        {
          "term": "application",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context referring to containerized software deployed on the cluster"
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource used to expose applications, capitalized indicating proper noun"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The primary platform/system being documented, core proper noun"
        },
        {
          "term": "application deployment",
          "tier": 2,
          "reasoning": "Domain concept describing the process of running applications on Kubernetes"
        },
        {
          "term": "scaling",
          "tier": 2,
          "reasoning": "Key Kubernetes operational concept for adjusting application capacity"
        },
        {
          "term": "updating",
          "tier": 2,
          "reasoning": "Technical process in Kubernetes for modifying deployed applications"
        },
        {
          "term": "deployed",
          "tier": 2,
          "reasoning": "Technical verb describing the state of an application running on Kubernetes"
        },
        {
          "term": "exposed",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context meaning making an application accessible via networking"
        },
        {
          "term": "manage",
          "tier": 3,
          "reasoning": "Technical verb in context of Kubernetes workload management operations"
        }
      ],
      "term_count": 10,
      "generated_at": "2026-02-08T21:01:11.179568",
      "elapsed_time": 8.368712663650513
    },
    {
      "chunk_id": "tasks_manage-kubernetes-objects_declarative-config_sec6",
      "doc_id": "tasks_manage-kubernetes-objects_declarative-config",
      "heading": "How apply calculates differences and merges changes",
      "source_file": "tasks_manage-kubernetes-objects_declarative-config.md",
      "content": "{{< caution >}}\nA *patch* is an update operation that is scoped to specific fields of an object\ninstead of the entire object. This enables updating only a specific set of fields\non an object without reading the object first.\n{{< /caution >}}\n\nWhen `kubectl apply` updates the live configuration for an object,\nit does so by sending a patch request to the API server. The\npatch defines updates scoped to specific fields of the live object\nconfiguration. The `kubectl apply` command calculates this patch request\nusing the configuration file, the live configuration, and the\n`last-applied-configuration` annotation stored in the live configuration.\n\n### Merge patch calculation\n\nThe `kubectl apply` command writes the contents of the configuration file to the\n`kubectl.kubernetes.io/last-applied-configuration` annotation. This\nis used to identify fields that have been removed from the configuration\nfile and need to be cleared from the live configuration. Here are the steps used\nto calculate which fields should be deleted or set:\n\n1. Calculate the fields to delete. These are the fields present in\n   `last-applied-configuration` and missing from the configuration file.\n2. Calculate the fields to add or set. These are the fields present in\n   the configuration file whose values don't match the live configuration.\n\nHere's an example. Suppose this is the configuration file for a Deployment object:\n\n{{% code_sample file=\"application/update_deployment.yaml\" %}}\n\nAlso, suppose this is the live configuration for the same Deployment object:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    # ...\n    # note that the annotation does not contain replicas\n    # because it was not updated through apply\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\n      \"metadata\":{\"annotations\":{},\"name\":\"nginx-deployment\",\"namespace\":\"default\"},\n      \"spec\":{\"minReadySeconds\":5,\"selector\":{\"matchLabels\":{\"app\":nginx}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"nginx\"}},\n      \"spec\":{\"containers\":[{\"image\":\"nginx:1.14.2\",\"name\":\"nginx\",\n      \"ports\":[{\"containerPort\":80}]}]}}}}\n  # ...\nspec:\n  replicas: 2 # written by scale\n  # ...\n  minReadySeconds: 5\n  selector:\n    matchLabels:\n      # ...\n      app: nginx\n  template:\n    metadata:\n      # ...\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx:1.14.2\n        # ...\n        name: nginx\n        ports:\n        - containerPort: 80\n      # ...\n```\n\nHere are the merge calculations that would be performed by `kubectl apply`:\n\n1. Calculate the fields to delete by reading values from\n   `last-applied-configuration` and comparing them to values in the\n   configuration file.\n   Clear fields explicitly set to null in the local object configuration file\n   regardless of whether they appear in the `last-applied-configuration`.\n   In this example, `minReadySeconds` appears in the\n   `last-applied-configuration` annotation, but does not appear in the configuration file.\n   **Action:** Clear `minReadySeconds` from the live configuration.\n2. Calculate the fields to set by reading values from the configuration\n   file and comparing them to values in the live configuration. In this example,\n   the value of `image` in the configuration file does not match\n   the value in the live configuration. **Action:** Set the value of `image` in the live configuration.\n3. Set the `last-applied-configuration` annotation to match the value\n   of the configuration file.\n4. Merge the results from 1, 2, 3 into a single patch request to the API server.\n\nHere is the live configuration that is the result of the merge:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  annotations:\n    # ...\n    # The annotation contains the updated image to nginx 1.16.1,\n    # but does not contain the updated replicas to 2\n    kubectl.kubernetes.io/last-applied-configuration: |\n      {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\n      \"metadata\":{\"annotations\":{},\"name\":\"nginx-deployment\",\"namespace\":\"default\"},\n      \"spec\":{\"selector\":{\"matchLabels\":{\"app\":nginx}},\"template\":{\"metadata\":{\"labels\":{\"app\":\"nginx\"}},\n      \"spec\":{\"containers\":[{\"image\":\"nginx:1.16.1\",\"name\":\"nginx\",\n      \"ports\":[{\"containerPort\":80}]}]}}}}\n    # ...\nspec:\n  selector:\n    matchLabels:\n      # ...\n      app: nginx\n  replicas: 2 # Set by `kubectl scale`.  Ignored by `kubectl apply`.\n  # minReadySeconds cleared by `kubectl apply`\n  # ...\n  template:\n    metadata:\n      # ...\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx:1.16.1 # Set by `kubectl apply`\n        # ...\n        name: nginx\n        ports:\n        - containerPort: 80\n        # ...\n      # ...\n    # ...\n  # ...\n```\n\n### How different types of fields are merged\n\nHow a particular field in a configuration file is merged with\nthe live configuration depends on the\ntype of the field. There are several types of fields:\n\n- *primitive*: A field of type string, integer, or boolean.\n  For example, `image` and `replicas` are primitive fields. **Action:** Replace.\n\n- *map*, also called *object*: A field of type map or a complex type that contains subfields. For example, `labels`,\n  `annotations`,`spec` and `metadata` are all maps. **Action:** Merge elements or subfields.\n\n- *list*: A field containing a list of items that can be either primitive types or maps.\n  For example, `containers`, `ports`, and `args` are lists. **Action:** Varies.\n\nWhen `kubectl apply` updates a map or list field, it typically does\nnot replace the entire field, but instead updates the individual subelements.\nFor instance, when merging the `spec` on a Deployment, the entire `spec` is\nnot replaced. Instead the subfields of `spec`, such as `replicas`, are compared\nand merged.\n\n### Merging changes to primitive fields\n\nPrimitive fields are replaced or cleared.\n\n{{< note >}}\n`-` is used for \"not applicable\" because the value is not used.\n{{< /note >}}\n\n| Field in object configuration file  | Field in live object configuration | Field in last-applied-configuration | Action                                    |\n|-------------------------------------|------------------------------------|-------------------------------------|-------------------------------------------|\n| Yes                                 | Yes                                | -                                   | Set live to configuration file value.  |\n| Yes                                 | No                                 | -                                   | Set live to local configuration.           |\n| No                                  | -                                  | Yes                                 | Clear from live configuration.            |\n| No                                  | -                                  | No                                  | Do nothing. Keep live value.             |\n\n### Merging changes to map fields\n\nFields that represent maps are merged by comparing each of the subfields or elements of the map:\n\n{{< note >}}\n`-` is used for \"not applicable\" because the value is not used.\n{{< /note >}}\n\n| Key in object configuration file    | Key in live object configuration   | Field in last-applied-configuration | Action                           |\n|-------------------------------------|------------------------------------|-------------------------------------|----------------------------------|\n| Yes                                 | Yes                                | -                                   | Compare sub fields values.        |\n| Yes                                 | No                                 | -                                   | Set live to local configuration.  |\n| No                                  | -                                  | Yes                                 | Delete from live configuration.   |\n| No                                  | -                                  | No                                  | Do nothing. Keep live value.     |\n\n### Merging changes for fields of type list\n\nMerging changes to a list uses one of three strategies:\n\n* Replace the list if all its elements are primitives.\n* Merge individual elements in a list of complex elements.\n* Merge a list of primitive elements.\n\nThe choice of strategy is made on a per-field basis.\n\n#### Replace the list if all its elements are primitives\n\nTreat the list the same as a primitive field. Replace or delete the\nentire list. This preserves ordering.\n\n**Example:** Use `kubectl apply` to update the `args` field of a Container in a Pod. This sets\nthe value of `args` in the live configuration to the value in the configuration file.\nAny `args` elements that had previously been added to the live configuration are lost.\nThe order of the `args` elements defined in the configuration file is\nretained in the live configuration.\n\n```yaml",
      "terms": [
        {
          "term": "patch",
          "tier": 2,
          "reasoning": "Core technical concept describing an update operation scoped to specific fields of an object"
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Specific kubectl command for applying configuration changes to Kubernetes objects"
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Primary Kubernetes CLI tool for interacting with clusters"
        },
        {
          "term": "live configuration",
          "tier": 2,
          "reasoning": "Domain concept referring to the current state of an object in the cluster"
        },
        {
          "term": "API server",
          "tier": 1,
          "reasoning": "Core Kubernetes component that receives patch requests"
        },
        {
          "term": "patch request",
          "tier": 2,
          "reasoning": "Technical concept for the request type sent to update specific fields"
        },
        {
          "term": "configuration file",
          "tier": 2,
          "reasoning": "Domain concept for the local file containing desired object state"
        },
        {
          "term": "last-applied-configuration",
          "tier": 1,
          "reasoning": "Specific Kubernetes annotation used to track previously applied configuration"
        },
        {
          "term": "annotation",
          "tier": 2,
          "reasoning": "Kubernetes metadata concept for attaching non-identifying information to objects"
        },
        {
          "term": "Merge patch calculation",
          "tier": 2,
          "reasoning": "Technical process describing how kubectl apply computes changes"
        },
        {
          "term": "kubectl.kubernetes.io/last-applied-configuration",
          "tier": 1,
          "reasoning": "Full annotation key name used by kubectl apply for tracking configuration"
        },
        {
          "term": "Deployment",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource type for managing application deployments"
        },
        {
          "term": "apiVersion",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the API version for the resource"
        },
        {
          "term": "apps/v1",
          "tier": 1,
          "reasoning": "Specific Kubernetes API group and version for apps resources"
        },
        {
          "term": "kind",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the type of resource"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Kubernetes object section containing identifying information"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes object section containing the desired state specification"
        },
        {
          "term": "replicas",
          "tier": 2,
          "reasoning": "Deployment field specifying the number of pod instances"
        },
        {
          "term": "minReadySeconds",
          "tier": 2,
          "reasoning": "Deployment spec field controlling minimum ready time before considering pod available"
        },
        {
          "term": "selector",
          "tier": 2,
          "reasoning": "Kubernetes field for matching pods to controllers via labels"
        },
        {
          "term": "matchLabels",
          "tier": 2,
          "reasoning": "Selector field for exact label matching"
        },
        {
          "term": "template",
          "tier": 2,
          "reasoning": "Pod template specification within a Deployment"
        },
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Kubernetes metadata for identifying and selecting objects"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Pod spec field listing container definitions"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container spec field specifying the container image to run"
        },
        {
          "term": "nginx",
          "tier": 1,
          "reasoning": "Specific container image/application name used in the example"
        },
        {
          "term": "nginx:1.14.2",
          "tier": 1,
          "reasoning": "Specific container image tag referenced in the example"
        },
        {
          "term": "nginx:1.16.1",
          "tier": 1,
          "reasoning": "Specific container image tag referenced in the merge result"
        },
        {
          "term": "ports",
          "tier": 2,
          "reasoning": "Container spec field for exposing container ports"
        },
        {
          "term": "containerPort",
          "tier": 2,
          "reasoning": "Port specification field for container network ports"
        },
        {
          "term": "name",
          "tier": 2,
          "reasoning": "Kubernetes metadata field for object identification"
        },
        {
          "term": "namespace",
          "tier": 2,
          "reasoning": "Kubernetes concept for logical resource isolation"
        },
        {
          "term": "default",
          "tier": 2,
          "reasoning": "Default Kubernetes namespace name"
        },
        {
          "term": "scale",
          "tier": 2,
          "reasoning": "Kubernetes operation for adjusting replica count"
        },
        {
          "term": "object",
          "tier": 2,
          "reasoning": "General Kubernetes term for API resources/entities"
        },
        {
          "term": "fields",
          "tier": 2,
          "reasoning": "Technical term for specific properties within Kubernetes objects"
        },
        {
          "term": "null",
          "tier": 3,
          "reasoning": "Technical value used to explicitly clear fields in configuration"
        }
      ],
      "term_count": 37,
      "generated_at": "2026-02-08T21:01:32.790316",
      "elapsed_time": 20.609029054641724
    },
    {
      "chunk_id": "tasks_administer-cluster_topology-manager_sec3",
      "doc_id": "tasks_administer-cluster_topology-manager",
      "heading": "Topology manager scopes and policies",
      "source_file": "tasks_administer-cluster_topology-manager.md",
      "content": "The Topology Manager currently:\n\n- aligns Pods of all QoS classes.\n- aligns the requested resources that Hint Provider provides topology hints for.\n\nIf these conditions are met, the Topology Manager will align the requested resources.\n\nIn order to customize how this alignment is carried out, the Topology Manager provides two\ndistinct options: `scope` and `policy`.\n\nThe `scope` defines the granularity at which you would like resource alignment to be performed,\nfor example, at the `pod` or `container` level. And the `policy` defines the actual policy used to\ncarry out the alignment, for example, `best-effort`, `restricted`, and `single-numa-node`.\nDetails on the various `scopes` and `policies` available today can be found below.\n\n{{< note >}}\nTo align CPU resources with other requested resources in a Pod spec, the CPU Manager should be\nenabled and proper CPU Manager policy should be configured on a Node.\nSee [Control CPU Management Policies on the Node](/docs/tasks/administer-cluster/cpu-management-policies/).\n{{< /note >}}\n\n{{< note >}}\nTo align memory (and hugepages) resources with other requested resources in a Pod spec, the Memory\nManager should be enabled and proper Memory Manager policy should be configured on a Node. Refer to\n[Memory Manager](/docs/tasks/administer-cluster/memory-manager/) documentation.\n{{< /note >}}",
      "terms": [
        {
          "term": "Topology Manager",
          "tier": 1,
          "reasoning": "Core Kubernetes component responsible for resource alignment across NUMA nodes."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object and workload unit."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Singular form of the core Kubernetes workload resource."
        },
        {
          "term": "QoS classes",
          "tier": 2,
          "reasoning": "Quality of Service classification system for Kubernetes Pods."
        },
        {
          "term": "Hint Provider",
          "tier": 1,
          "reasoning": "Named component that provides topology hints for resource alignment."
        },
        {
          "term": "topology hints",
          "tier": 2,
          "reasoning": "Domain concept describing hints used for NUMA-aware resource placement."
        },
        {
          "term": "scope",
          "tier": 2,
          "reasoning": "Configuration option defining granularity of resource alignment."
        },
        {
          "term": "policy",
          "tier": 2,
          "reasoning": "Configuration option defining the alignment strategy used by Topology Manager."
        },
        {
          "term": "resource alignment",
          "tier": 2,
          "reasoning": "Technical process of aligning resources across topology domains."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Core domain concept representing the unit of execution within a Pod."
        },
        {
          "term": "best-effort",
          "tier": 2,
          "reasoning": "Named Topology Manager policy option for alignment strategy."
        },
        {
          "term": "restricted",
          "tier": 2,
          "reasoning": "Named Topology Manager policy option for stricter alignment."
        },
        {
          "term": "single-numa-node",
          "tier": 2,
          "reasoning": "Named Topology Manager policy requiring all resources from one NUMA node."
        },
        {
          "term": "CPU resources",
          "tier": 2,
          "reasoning": "Technical term for compute resources managed by CPU Manager."
        },
        {
          "term": "CPU Manager",
          "tier": 1,
          "reasoning": "Kubernetes component that manages CPU allocation policies on nodes."
        },
        {
          "term": "CPU Manager policy",
          "tier": 2,
          "reasoning": "Configuration setting for CPU Manager behavior."
        },
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a worker machine in the cluster."
        },
        {
          "term": "CPU Management Policies",
          "tier": 2,
          "reasoning": "Domain concept for policies controlling CPU allocation on nodes."
        },
        {
          "term": "memory",
          "tier": 3,
          "reasoning": "System resource type managed for NUMA-aware allocation."
        },
        {
          "term": "hugepages",
          "tier": 2,
          "reasoning": "Linux memory feature for large memory pages, managed by Memory Manager."
        },
        {
          "term": "Memory Manager",
          "tier": 1,
          "reasoning": "Kubernetes component that manages memory allocation policies."
        },
        {
          "term": "Memory Manager policy",
          "tier": 2,
          "reasoning": "Configuration setting for Memory Manager behavior."
        },
        {
          "term": "Pod spec",
          "tier": 2,
          "reasoning": "Technical term for the specification section of a Pod definition."
        },
        {
          "term": "requested resources",
          "tier": 2,
          "reasoning": "Domain concept for resources explicitly requested in Pod specifications."
        },
        {
          "term": "scopes",
          "tier": 2,
          "reasoning": "Plural form referring to available Topology Manager scope options."
        },
        {
          "term": "policies",
          "tier": 2,
          "reasoning": "Plural form referring to available Topology Manager policy options."
        },
        {
          "term": "pod",
          "tier": 2,
          "reasoning": "Scope option value for pod-level resource alignment."
        },
        {
          "term": "NUMA",
          "tier": 3,
          "reasoning": "Non-Uniform Memory Access architecture concept implicit in single-numa-node policy."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Implicit domain concept as context for node administration."
        }
      ],
      "term_count": 29,
      "generated_at": "2026-02-08T21:01:48.544507",
      "elapsed_time": 14.7516770362854
    },
    {
      "chunk_id": "concepts_services-networking_ingress_sec1",
      "doc_id": "concepts_services-networking_ingress",
      "heading": "Terminology",
      "source_file": "concepts_services-networking_ingress.md",
      "content": "For clarity, this guide defines the following terms:\n\n* Node: A worker machine in Kubernetes, part of a cluster.\n* Cluster: A set of Nodes that run containerized applications managed by Kubernetes.\n  For this example, and in most common Kubernetes deployments, nodes in the cluster\n  are not part of the public internet.\n* Edge router: A router that enforces the firewall policy for your cluster. This\n  could be a gateway managed by a cloud provider or a physical piece of hardware.\n* Cluster network: A set of links, logical or physical, that facilitate communication\n  within a cluster according to the Kubernetes [networking model](/docs/concepts/cluster-administration/networking/).\n* Service: A Kubernetes {{< glossary_tooltip term_id=\"service\" >}} that identifies\n  a set of Pods using {{< glossary_tooltip text=\"label\" term_id=\"label\" >}} selectors.\n  Unless mentioned otherwise, Services are assumed to have virtual IPs only routable within the cluster network.",
      "terms": [
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Core Kubernetes resource representing a worker machine in the cluster."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The primary container orchestration platform being documented."
        },
        {
          "term": "Cluster",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes architectural concept representing a set of nodes."
        },
        {
          "term": "containerized applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications packaged in containers."
        },
        {
          "term": "Edge router",
          "tier": 2,
          "reasoning": "Network infrastructure component that enforces firewall policy at cluster boundary."
        },
        {
          "term": "router",
          "tier": 3,
          "reasoning": "General networking term with specific meaning in cluster context."
        },
        {
          "term": "firewall policy",
          "tier": 2,
          "reasoning": "Security concept governing network traffic rules for the cluster."
        },
        {
          "term": "gateway",
          "tier": 2,
          "reasoning": "Network component that can serve as edge router, managed by cloud provider."
        },
        {
          "term": "cloud provider",
          "tier": 2,
          "reasoning": "Infrastructure concept referring to managed cloud services hosting Kubernetes."
        },
        {
          "term": "Cluster network",
          "tier": 2,
          "reasoning": "Kubernetes networking concept describing internal cluster communication infrastructure."
        },
        {
          "term": "networking model",
          "tier": 2,
          "reasoning": "Kubernetes architectural concept defining how network communication works."
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Core Kubernetes API object that identifies and exposes a set of Pods."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Core Kubernetes resource representing the smallest deployable unit."
        },
        {
          "term": "label",
          "tier": 2,
          "reasoning": "Kubernetes concept for key-value pairs used to organize and select resources."
        },
        {
          "term": "selectors",
          "tier": 2,
          "reasoning": "Kubernetes mechanism for identifying resources based on labels."
        },
        {
          "term": "virtual IPs",
          "tier": 2,
          "reasoning": "Networking concept for IP addresses assigned to Services for internal routing."
        },
        {
          "term": "worker machine",
          "tier": 2,
          "reasoning": "Infrastructure term describing the role of a Node in the cluster."
        },
        {
          "term": "Nodes",
          "tier": 1,
          "reasoning": "Plural form of Node, core Kubernetes resource appearing in cluster definition."
        },
        {
          "term": "public internet",
          "tier": 3,
          "reasoning": "Networking context term distinguishing cluster-internal from external networks."
        },
        {
          "term": "hardware",
          "tier": 3,
          "reasoning": "Infrastructure term referring to physical edge router implementation."
        },
        {
          "term": "links",
          "tier": 3,
          "reasoning": "Networking term describing connections in cluster network."
        },
        {
          "term": "communication",
          "tier": 3,
          "reasoning": "Technical term describing data exchange within cluster network context."
        },
        {
          "term": "routable",
          "tier": 3,
          "reasoning": "Networking term describing accessibility of virtual IPs within cluster."
        }
      ],
      "term_count": 23,
      "generated_at": "2026-02-08T21:02:01.952858",
      "elapsed_time": 12.405556917190552
    },
    {
      "chunk_id": "tasks_configure-pod-container_configure-pod-configmap_sec19",
      "doc_id": "tasks_configure-pod-container_configure-pod-configmap",
      "heading": "You might already have removed the next set",
      "source_file": "tasks_configure-pod-container_configure-pod-configmap.md",
      "content": "kubectl delete configmaps/special-config configmaps/env-config\nkubectl delete configmap -l 'game-config in (config-4,config-5)'\n```\n\nRemove the `kustomization.yaml` file that you used to generate the ConfigMap:\n\n```bash\nrm kustomization.yaml\n```\n\nIf you created a directory `configure-pod-container` and no longer need it, you should remove that too,\nor move it into the trash can / deleted files location.\n\n```bash\nrm -r configure-pod-container\n```",
      "terms": [
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Primary Kubernetes CLI tool used for cluster management and resource manipulation."
        },
        {
          "term": "configmaps",
          "tier": 1,
          "reasoning": "Kubernetes API object for storing non-confidential configuration data as key-value pairs."
        },
        {
          "term": "ConfigMap",
          "tier": 1,
          "reasoning": "Kubernetes API resource referenced in the context of generation and deletion."
        },
        {
          "term": "special-config",
          "tier": 1,
          "reasoning": "Named ConfigMap resource being deleted in the example command."
        },
        {
          "term": "env-config",
          "tier": 1,
          "reasoning": "Named ConfigMap resource being deleted in the example command."
        },
        {
          "term": "config-4",
          "tier": 1,
          "reasoning": "Named configuration resource referenced in label selector."
        },
        {
          "term": "config-5",
          "tier": 1,
          "reasoning": "Named configuration resource referenced in label selector."
        },
        {
          "term": "game-config",
          "tier": 1,
          "reasoning": "Label key used for selecting ConfigMap resources."
        },
        {
          "term": "kustomization.yaml",
          "tier": 1,
          "reasoning": "Kustomize configuration file used to generate Kubernetes resources."
        },
        {
          "term": "configure-pod-container",
          "tier": 2,
          "reasoning": "Directory name related to pod and container configuration workflow."
        },
        {
          "term": "delete",
          "tier": 2,
          "reasoning": "Kubernetes kubectl subcommand for removing resources from the cluster."
        },
        {
          "term": "kubectl delete",
          "tier": 2,
          "reasoning": "Complete command for deleting Kubernetes resources."
        },
        {
          "term": "-l",
          "tier": 3,
          "reasoning": "kubectl flag for label selector used to filter resources."
        },
        {
          "term": "rm",
          "tier": 3,
          "reasoning": "Unix/Linux command for removing files, used in cleanup context."
        },
        {
          "term": "rm -r",
          "tier": 3,
          "reasoning": "Unix/Linux command for recursive directory removal."
        },
        {
          "term": "bash",
          "tier": 3,
          "reasoning": "Shell environment specified for executing the cleanup commands."
        },
        {
          "term": "directory",
          "tier": 3,
          "reasoning": "File system concept relevant to the cleanup procedure."
        },
        {
          "term": "pod",
          "tier": 1,
          "reasoning": "Core Kubernetes workload resource referenced in directory name 'configure-pod-container'."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept referenced in directory name 'configure-pod-container'."
        }
      ],
      "term_count": 19,
      "generated_at": "2026-02-08T21:02:13.685475",
      "elapsed_time": 10.729471683502197
    },
    {
      "chunk_id": "reference_node_node-status_sec6",
      "doc_id": "reference_node_node-status",
      "heading": "Declared features {#declaredfeatures}",
      "source_file": "reference_node_node-status.md",
      "content": "{{< feature-state feature_gate_name=\"NodeDeclaredFeatures\" >}}\n\nThis field lists specific Kubernetes features that are currently enabled on the\nnode's kubelet via [feature gates](/docs/reference/command-line-tools-reference/feature-gates/).\nThe features are reported by the kubelet as a list of strings in the\n`.status.declaredFeatures` field of the Node object.\n\nThis field is intended for newer features under active development; features that\nhave graduated and no longer require a feature gate are considered baseline and\nare not declared in this field. This reflects the enablement of Kubernetes\nfeatures, not the underlying operating system or kernel capabilities of the node.\n\nSee [Node Declared Features](/docs/concepts/scheduling-eviction/node-declared-features/)\nfor more details.",
      "terms": [
        {
          "term": "NodeDeclaredFeatures",
          "tier": 1,
          "reasoning": "Specific Kubernetes feature gate name that controls node feature declaration functionality."
        },
        {
          "term": "feature_gate_name",
          "tier": 2,
          "reasoning": "Technical parameter reference for feature gate configuration in Kubernetes."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform this documentation describes."
        },
        {
          "term": "kubelet",
          "tier": 1,
          "reasoning": "Core Kubernetes node agent component that reports features."
        },
        {
          "term": "feature gates",
          "tier": 2,
          "reasoning": "Kubernetes mechanism for enabling/disabling experimental or optional features."
        },
        {
          "term": "node",
          "tier": 2,
          "reasoning": "Kubernetes worker machine concept where kubelet runs and features are reported."
        },
        {
          "term": "Node",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a worker machine in the cluster."
        },
        {
          "term": ".status.declaredFeatures",
          "tier": 1,
          "reasoning": "Specific API field path in the Node object where features are reported."
        },
        {
          "term": "Node object",
          "tier": 1,
          "reasoning": "The Kubernetes API resource representing a node in the cluster."
        },
        {
          "term": "features",
          "tier": 2,
          "reasoning": "Technical concept referring to Kubernetes capabilities that can be enabled/disabled."
        },
        {
          "term": "strings",
          "tier": 3,
          "reasoning": "Data type used to represent the list of declared features."
        },
        {
          "term": "field",
          "tier": 3,
          "reasoning": "Technical term for a property within a Kubernetes API object."
        },
        {
          "term": "operating system",
          "tier": 3,
          "reasoning": "System software concept distinguished from Kubernetes feature enablement."
        },
        {
          "term": "kernel",
          "tier": 3,
          "reasoning": "OS kernel capabilities explicitly distinguished from Kubernetes features."
        },
        {
          "term": "Node Declared Features",
          "tier": 1,
          "reasoning": "Named Kubernetes concept/feature for declaring node capabilities."
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Kubernetes process referenced in the documentation path for node declared features."
        },
        {
          "term": "eviction",
          "tier": 2,
          "reasoning": "Kubernetes concept referenced in the documentation path alongside scheduling."
        },
        {
          "term": "baseline",
          "tier": 2,
          "reasoning": "Technical term describing graduated features that no longer need feature gates."
        },
        {
          "term": "graduated",
          "tier": 2,
          "reasoning": "Feature lifecycle stage indicating a feature has become stable/baseline."
        },
        {
          "term": "enabled",
          "tier": 2,
          "reasoning": "Technical state describing whether a feature is active on a node."
        },
        {
          "term": "capabilities",
          "tier": 2,
          "reasoning": "Technical term for node abilities, distinguished between OS and Kubernetes levels."
        }
      ],
      "term_count": 21,
      "generated_at": "2026-02-08T21:02:28.001835",
      "elapsed_time": 13.313749074935913
    },
    {
      "chunk_id": "concepts_policy__index_sec3",
      "doc_id": "concepts_policy__index",
      "heading": "Apply policies using ValidatingAdmissionPolicy",
      "source_file": "concepts_policy__index.md",
      "content": "Validating admission policies allow configurable validation checks to be executed in the API server using the Common Expression Language (CEL). For example, a `ValidatingAdmissionPolicy` can be used to disallow use of the `latest` image tag.\n\nA `ValidatingAdmissionPolicy` operates on an API request and can be used to block, audit, and warn users about non-compliant configurations.\n\nDetails on the `ValidatingAdmissionPolicy` API, with examples, are documented in a dedicated section:\n* [Validating Admission Policy](/docs/reference/access-authn-authz/validating-admission-policy/)",
      "terms": [
        {
          "term": "ValidatingAdmissionPolicy",
          "tier": 1,
          "reasoning": "Core Kubernetes API object for configurable validation checks in the API server."
        },
        {
          "term": "Validating admission policies",
          "tier": 1,
          "reasoning": "Named Kubernetes feature for admission control validation."
        },
        {
          "term": "Validating Admission Policy",
          "tier": 1,
          "reasoning": "Proper noun reference to the Kubernetes API resource and documentation section."
        },
        {
          "term": "API server",
          "tier": 1,
          "reasoning": "Core Kubernetes control plane component that processes API requests."
        },
        {
          "term": "Common Expression Language",
          "tier": 2,
          "reasoning": "Domain-specific language used for writing validation expressions in Kubernetes."
        },
        {
          "term": "CEL",
          "tier": 3,
          "reasoning": "Acronym for Common Expression Language, a technical standard used in validation policies."
        },
        {
          "term": "API request",
          "tier": 2,
          "reasoning": "Technical concept referring to requests made to the Kubernetes API server."
        },
        {
          "term": "validation checks",
          "tier": 2,
          "reasoning": "Domain concept describing the verification process performed by admission policies."
        },
        {
          "term": "configurable validation",
          "tier": 2,
          "reasoning": "Technical concept describing customizable validation behavior."
        },
        {
          "term": "image tag",
          "tier": 2,
          "reasoning": "Container domain concept referring to version identifiers for container images."
        },
        {
          "term": "latest",
          "tier": 2,
          "reasoning": "Specific image tag value with special meaning in container ecosystems, often discouraged."
        },
        {
          "term": "block",
          "tier": 2,
          "reasoning": "Admission control action that prevents non-compliant configurations from being applied."
        },
        {
          "term": "audit",
          "tier": 2,
          "reasoning": "Admission control action that logs policy violations without blocking."
        },
        {
          "term": "warn",
          "tier": 2,
          "reasoning": "Admission control action that alerts users about non-compliant configurations."
        },
        {
          "term": "non-compliant configurations",
          "tier": 2,
          "reasoning": "Domain concept describing configurations that violate defined policies."
        },
        {
          "term": "API",
          "tier": 3,
          "reasoning": "General technical term for Application Programming Interface, contextually relevant to Kubernetes."
        },
        {
          "term": "admission",
          "tier": 2,
          "reasoning": "Kubernetes domain concept referring to the process of validating and mutating API requests."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:02:39.380749",
      "elapsed_time": 10.375048160552979
    },
    {
      "chunk_id": "concepts_policy__index_sec1",
      "doc_id": "concepts_policy__index",
      "heading": "Apply policies using API objects",
      "source_file": "concepts_policy__index.md",
      "content": "Some API objects act as policies. Here are some examples:\n* [NetworkPolicies](/docs/concepts/services-networking/network-policies/) can be used to restrict ingress and egress traffic for a workload.\n* [LimitRanges](/docs/concepts/policy/limit-range/) manage resource allocation constraints across different object kinds.\n* [ResourceQuotas](/docs/concepts/policy/resource-quotas/) limit resource consumption for a {{< glossary_tooltip text=\"namespace\" term_id=\"namespace\" >}}.",
      "terms": [
        {
          "term": "API objects",
          "tier": 2,
          "reasoning": "Core Kubernetes concept referring to the persistent entities in the system that represent cluster state."
        },
        {
          "term": "policies",
          "tier": 2,
          "reasoning": "Domain concept describing API objects that enforce rules and constraints on cluster behavior."
        },
        {
          "term": "NetworkPolicies",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that controls network traffic flow for workloads."
        },
        {
          "term": "ingress",
          "tier": 2,
          "reasoning": "Networking concept referring to incoming traffic to a workload or cluster."
        },
        {
          "term": "egress",
          "tier": 2,
          "reasoning": "Networking concept referring to outgoing traffic from a workload or cluster."
        },
        {
          "term": "traffic",
          "tier": 3,
          "reasoning": "Technical networking term describing data flow in the context of network policies."
        },
        {
          "term": "workload",
          "tier": 2,
          "reasoning": "Kubernetes domain concept referring to applications running on the cluster."
        },
        {
          "term": "LimitRanges",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that manages resource allocation constraints."
        },
        {
          "term": "resource allocation",
          "tier": 2,
          "reasoning": "Domain concept describing how compute resources are distributed to objects."
        },
        {
          "term": "constraints",
          "tier": 2,
          "reasoning": "Technical term describing limitations or rules applied to resource usage."
        },
        {
          "term": "object kinds",
          "tier": 2,
          "reasoning": "Kubernetes concept referring to the types/categories of API objects."
        },
        {
          "term": "ResourceQuotas",
          "tier": 1,
          "reasoning": "Named Kubernetes API resource that limits resource consumption per namespace."
        },
        {
          "term": "resource consumption",
          "tier": 2,
          "reasoning": "Domain concept describing the usage of compute resources by workloads."
        },
        {
          "term": "namespace",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for logical partitioning of cluster resources."
        },
        {
          "term": "restrict",
          "tier": 3,
          "reasoning": "Technical action term describing the enforcement behavior of network policies."
        },
        {
          "term": "limit",
          "tier": 3,
          "reasoning": "Technical action term describing the enforcement behavior of resource quotas."
        },
        {
          "term": "ingress and egress traffic",
          "tier": 2,
          "reasoning": "Compound networking concept describing bidirectional network flow control."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:02:51.210860",
      "elapsed_time": 10.827153205871582
    },
    {
      "chunk_id": "concepts_services-networking_ingress_sec7",
      "doc_id": "concepts_services-networking_ingress",
      "heading": "Types of Ingress",
      "source_file": "concepts_services-networking_ingress.md",
      "content": "### Ingress backed by a single Service {#single-service-ingress}\n\nThere are existing Kubernetes concepts that allow you to expose a single Service\n(see [alternatives](#alternatives)). You can also do this with an Ingress by specifying a\n*default backend* with no rules.\n\n{{% code_sample file=\"service/networking/test-ingress.yaml\" %}}\n\nIf you create it using `kubectl apply -f` you should be able to view the state\nof the Ingress you added:\n\n```bash\nkubectl get ingress test-ingress\n```\n\n```\nNAME           CLASS         HOSTS   ADDRESS         PORTS   AGE\ntest-ingress   external-lb   *       203.0.113.123   80      59s\n```\n\nWhere `203.0.113.123` is the IP allocated by the Ingress controller to satisfy\nthis Ingress.\n\n{{< note >}}\nIngress controllers and load balancers may take a minute or two to allocate an IP address.\nUntil that time, you often see the address listed as `<pending>`.\n{{< /note >}}\n\n### Simple fanout\n\nA fanout configuration routes traffic from a single IP address to more than one Service,\nbased on the HTTP URI being requested. An Ingress allows you to keep the number of load balancers\ndown to a minimum. For example, a setup like:\n\n{{< figure src=\"/docs/images/ingressFanOut.svg\" alt=\"ingress-fanout-diagram\" class=\"diagram-large\" caption=\"Figure. Ingress Fan Out\" link=\"https://mermaid.live/edit#pako:eNqNUslOwzAQ_RXLvYCUhMQpUFzUUzkgcUBwbHpw4klr4diR7bCo8O8k2FFbFomLPZq3jP00O1xpDpjijWHtFt09zAuFUCUFKHey8vf6NE7QrdoYsDZumGIb4Oi6NAskNeOoZJKpCgxK4oXwrFVgRyi7nCVXWZKRPMlysv5yD6Q4Xryf1Vq_WzDPooJs9egLNDbolKTpT03JzKgh3zWEztJZ0Niu9L-qZGcdmAMfj4cxvWmreba613z9C0B-AMQD-V_AdA-A4j5QZu0SatRKJhSqhZR0wjmPrDP6CeikrutQxy-Cuy2dtq9RpaU2dJKm6fzI5Glmg0VOLio4_5dLjx27hFSC015KJ2VZHtuQvY2fuHcaE43G0MaCREOow_FV5cMxHZ5-oPX75UM5avuXhXuOI9yAaZjg_aLuBl6B3RYaKDDtSw4166QrcKE-emrXcubghgunDaY1kxYizDqnH99UhakzHYykpWD9hjS--fEJoIELqQ\" >}}\n\nIt would require an Ingress such as:\n\n{{% code_sample file=\"service/networking/simple-fanout-example.yaml\" %}}\n\nWhen you create the Ingress with `kubectl apply -f`:\n\n```shell\nkubectl describe ingress simple-fanout-example\n```\n\n```\nName:             simple-fanout-example\nNamespace:        default\nAddress:          178.91.123.132\nDefault backend:  default-http-backend:80 (10.8.2.3:8080)\nRules:\n  Host         Path  Backends\n  ----         ----  --------\n  foo.bar.com\n               /foo   service1:4200 (10.8.0.90:4200)\n               /bar   service2:8080 (10.8.0.91:8080)\nEvents:\n  Type     Reason  Age                From                     Message\n  ----     ------  ----               ----                     -------\n  Normal   ADD     22s                loadbalancer-controller  default/test\n```\n\nThe Ingress controller provisions an implementation-specific load balancer\nthat satisfies the Ingress, as long as the Services (`service1`, `service2`) exist.\nWhen it has done so, you can see the address of the load balancer at the\nAddress field.\n\n{{< note >}}\nDepending on the [Ingress controller](/docs/concepts/services-networking/ingress-controllers/)\nyou are using, you may need to create a default-http-backend\n[Service](/docs/concepts/services-networking/service/).\n{{< /note >}}\n\n### Name based virtual hosting\n\nName-based virtual hosts support routing HTTP traffic to multiple host names at the same IP address.\n\n{{< figure src=\"/docs/images/ingressNameBased.svg\" alt=\"ingress-namebase-diagram\" class=\"diagram-large\" caption=\"Figure. Ingress Name Based Virtual hosting\" link=\"https://mermaid.live/edit#pako:eNqNkl9PwyAUxb8KYS-atM1Kp05m9qSJJj4Y97jugcLtRqTQAPVPdN_dVlq3qUt8gZt7zvkBN7xjbgRgiteW1Rt0_zjLNUJcSdD-ZBn21WmcoDu9tuBcXDHN1iDQVWHnSBkmUMEU0xwsSuK5DK5l745QejFNLtMkJVmSZmT1Re9NcTz_uDXOU1QakxTMJtxUHw7ss-SQLhehQEODTsdH4l20Q-zFyc84-Y67pghv5apxHuweMuj9eS2_NiJdPhix-kMgvwQShOyYMNkJoEUYM3PuGkpUKyY1KqVSdCSEiJy35gnoqCzLvo5fpPAbOqlfI26UsXQ0Ho9nB5CnqesRGTnncPYvSqsdUvqp9KRdlI6KojjEkB0mnLgjDRONhqENBYm6oXbLV5V1y6S7-l42_LowlIN2uFm_twqOcAW2YlK0H_i9c-bYb6CCHNO2FFCyRvkc53rbWptaMA83QnpjMS2ZchBh1nizeNMcU28bGEzXkrV_pArN7Sc0rBTu\" >}}\n\nThe following Ingress tells the backing load balancer to route requests based on\nthe [Host header](https://tools.ietf.org/html/rfc7230#section-5.4).\n\n{{% code_sample file=\"service/networking/name-virtual-host-ingress.yaml\" %}}\n\nIf you create an Ingress resource without any hosts defined in the rules, then any\nweb traffic to the IP address of your Ingress controller can be matched without a name based\nvirtual host being required.\n\nFor example, the following Ingress routes traffic\nrequested for `first.bar.com` to `service1`, `second.bar.com` to `service2`,\nand any traffic whose request host header doesn't match `first.bar.com`\nand `second.bar.com` to `service3`.\n\n{{% code_sample file=\"service/networking/name-virtual-host-ingress-no-third-host.yaml\" %}}\n\n### TLS\n\nYou can secure an Ingress by specifying a {{< glossary_tooltip term_id=\"secret\" >}}\nthat contains a TLS private key and certificate. The Ingress resource only\nsupports a single TLS port, 443, and assumes TLS termination at the ingress point\n(traffic to the Service and its Pods is in plaintext).\nIf the TLS configuration section in an Ingress specifies different hosts, they are\nmultiplexed on the same port according to the hostname specified through the\nSNI TLS extension (provided the Ingress controller supports SNI). The TLS secret\nmust contain keys named `tls.crt` and `tls.key` that contain the certificate\nand private key to use for TLS. For example:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: testsecret-tls\n  namespace: default\ndata:\n  tls.crt: base64 encoded cert\n  tls.key: base64 encoded key\ntype: kubernetes.io/tls\n```\n\nReferencing this secret in an Ingress tells the Ingress controller to\nsecure the channel from the client to the load balancer using TLS. You need to make\nsure the TLS secret you created came from a certificate that contains a Common\nName (CN), also known as a Fully Qualified Domain Name (FQDN) for `https-example.foo.com`.\n\n{{< note >}}\nKeep in mind that TLS will not work on the default rule because the\ncertificates would have to be issued for all the possible sub-domains. Therefore,\n`hosts` in the `tls` section need to explicitly match the `host` in the `rules`\nsection.\n{{< /note >}}\n\n{{% code_sample file=\"service/networking/tls-example-ingress.yaml\" %}}\n\n{{< note >}}\nThere is a gap between TLS features supported by various ingress controllers.\nYou should refer to the documentation for the ingress controller(s) you've chosen to\nunderstand how TLS works in your environment.\n{{< /note >}}\n\n### Load balancing {#load-balancing}\n\nAn Ingress controller is bootstrapped with some load balancing policy settings\nthat it applies to all Ingress, such as the load balancing algorithm, backend\nweight scheme, and others. More advanced load balancing concepts\n(e.g. persistent sessions, dynamic weights) are not yet exposed through the\nIngress. You can instead get these features through the load balancer used for\na Service.\n\nIt's also worth noting that even though health checks are not exposed directly\nthrough the Ingress, there exist parallel concepts in Kubernetes such as\n[readiness probes](/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)\nthat allow you to achieve the same end result. Please review the controller\nspecific documentation to see how they handle health checks.",
      "terms": [
        {
          "term": "Ingress",
          "tier": 1,
          "reasoning": "Core Kubernetes API object for managing external access to services in a cluster."
        },
        {
          "term": "Service",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object that exposes applications running on pods."
        },
        {
          "term": "default backend",
          "tier": 2,
          "reasoning": "Ingress configuration concept specifying where traffic goes when no rules match."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool used for cluster management."
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Specific kubectl command for applying configuration to resources."
        },
        {
          "term": "kubectl get",
          "tier": 1,
          "reasoning": "Specific kubectl command for retrieving resource information."
        },
        {
          "term": "kubectl describe",
          "tier": 1,
          "reasoning": "Specific kubectl command for showing detailed resource information."
        },
        {
          "term": "Ingress controller",
          "tier": 1,
          "reasoning": "Kubernetes component that implements Ingress resources and manages load balancing."
        },
        {
          "term": "load balancer",
          "tier": 2,
          "reasoning": "Infrastructure component that distributes network traffic across multiple services."
        },
        {
          "term": "IP address",
          "tier": 3,
          "reasoning": "Network addressing concept used for routing traffic to Ingress resources."
        },
        {
          "term": "fanout",
          "tier": 2,
          "reasoning": "Ingress routing pattern that distributes traffic from single IP to multiple services."
        },
        {
          "term": "HTTP URI",
          "tier": 3,
          "reasoning": "Protocol-specific identifier used for path-based routing decisions."
        },
        {
          "term": "HTTP",
          "tier": 3,
          "reasoning": "Application layer protocol used for Ingress traffic routing."
        },
        {
          "term": "Name based virtual hosting",
          "tier": 2,
          "reasoning": "Ingress routing technique supporting multiple hostnames at same IP address."
        },
        {
          "term": "virtual hosting",
          "tier": 2,
          "reasoning": "Networking concept for hosting multiple domains on single IP address."
        },
        {
          "term": "host names",
          "tier": 3,
          "reasoning": "DNS names used for name-based virtual hosting routing."
        },
        {
          "term": "Namespace",
          "tier": 1,
          "reasoning": "Kubernetes resource for organizing and isolating cluster resources."
        },
        {
          "term": "default-http-backend",
          "tier": 1,
          "reasoning": "Specific Service name required by some Ingress controllers for fallback routing."
        },
        {
          "term": "Address",
          "tier": 2,
          "reasoning": "Ingress field showing the allocated external IP for the resource."
        },
        {
          "term": "Rules",
          "tier": 2,
          "reasoning": "Ingress configuration section defining routing paths and backends."
        },
        {
          "term": "Host",
          "tier": 2,
          "reasoning": "Ingress rule field specifying the hostname for routing."
        },
        {
          "term": "Path",
          "tier": 2,
          "reasoning": "Ingress rule field specifying URL path for routing decisions."
        },
        {
          "term": "Backends",
          "tier": 2,
          "reasoning": "Ingress configuration specifying target services for routed traffic."
        },
        {
          "term": "PORTS",
          "tier": 2,
          "reasoning": "Network ports exposed by the Ingress resource."
        },
        {
          "term": "CLASS",
          "tier": 2,
          "reasoning": "Ingress field specifying which Ingress controller should handle the resource."
        },
        {
          "term": "external-lb",
          "tier": 1,
          "reasoning": "Specific Ingress class name shown in example output."
        },
        {
          "term": "test-ingress",
          "tier": 1,
          "reasoning": "Example Ingress resource name used in documentation."
        },
        {
          "term": "simple-fanout-example",
          "tier": 1,
          "reasoning": "Example Ingress resource name demonstrating fanout configuration."
        },
        {
          "term": "service1",
          "tier": 1,
          "reasoning": "Example Service name used as backend in fanout configuration."
        },
        {
          "term": "service2",
          "tier": 1,
          "reasoning": "Example Service name used as backend in fanout configuration."
        },
        {
          "term": "foo.bar.com",
          "tier": 3,
          "reasoning": "Example hostname used in Ingress routing rules."
        },
        {
          "term": "loadbalancer-controller",
          "tier": 1,
          "reasoning": "Component name shown in Events that manages load balancer provisioning."
        },
        {
          "term": "Events",
          "tier": 2,
          "reasoning": "Kubernetes resource field showing lifecycle events for resources."
        },
        {
          "term": "traffic",
          "tier": 2,
          "reasoning": "Network traffic concept central to Ingress routing functionality."
        },
        {
          "term": "routing",
          "tier": 2,
          "reasoning": "Network concept for directing traffic to appropriate destinations."
        }
      ],
      "term_count": 35,
      "generated_at": "2026-02-08T21:03:15.113496",
      "elapsed_time": 22.899235486984253
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec19",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`Key`     {#apiserver-config-k8s-io-v1-Key}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [AESConfiguration](#apiserver-config-k8s-io-v1-AESConfiguration)\n\n- [SecretboxConfiguration](#apiserver-config-k8s-io-v1-SecretboxConfiguration)\n\n\n<p>Key contains name and secret of the provided key for a transformer.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>name</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>name is the name of the key to be used while storing data to disk.</p>\n</td>\n</tr>\n<tr><td><code>secret</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>secret is the actual key, encoded in base64.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AESConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for AES encryption settings."
        },
        {
          "term": "SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for Secretbox encryption settings."
        },
        {
          "term": "Key",
          "tier": 1,
          "reasoning": "Named API object/struct that contains name and secret for a transformer."
        },
        {
          "term": "transformer",
          "tier": 2,
          "reasoning": "Domain concept referring to a component that transforms/encrypts data in Kubernetes."
        },
        {
          "term": "name",
          "tier": 2,
          "reasoning": "Required field identifier used for storing data to disk in encryption context."
        },
        {
          "term": "secret",
          "tier": 2,
          "reasoning": "Domain term referring to the actual encryption key material."
        },
        {
          "term": "base64",
          "tier": 3,
          "reasoning": "Encoding standard used for representing the secret key."
        },
        {
          "term": "apiserver-config-k8s-io-v1-AESConfiguration",
          "tier": 1,
          "reasoning": "Full API group/version/kind reference for AESConfiguration resource."
        },
        {
          "term": "apiserver-config-k8s-io-v1-SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Full API group/version/kind reference for SecretboxConfiguration resource."
        },
        {
          "term": "disk",
          "tier": 3,
          "reasoning": "Storage medium referenced in context of data persistence."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term describing API object structure components."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the name and secret fields."
        },
        {
          "term": "encoded",
          "tier": 3,
          "reasoning": "Technical term describing the transformation applied to the secret key."
        }
      ],
      "term_count": 13,
      "generated_at": "2026-02-08T21:03:25.040628",
      "elapsed_time": 8.92354154586792
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1beta1_sec6",
      "doc_id": "reference_config-api_apiserver-config.v1beta1",
      "heading": "`AnonymousAuthCondition`     {#apiserver-k8s-io-v1beta1-AnonymousAuthCondition}",
      "source_file": "reference_config-api_apiserver-config.v1beta1.md",
      "content": "**Appears in:**\n\n- [AnonymousAuthConfig](#apiserver-k8s-io-v1beta1-AnonymousAuthConfig)\n\n\n<p>AnonymousAuthCondition describes the condition under which anonymous auth\nshould be enabled.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>path</code> <B>[Required]</B><br/>\n<code>string</code>\n</td>\n<td>\n   <p>Path for which anonymous auth is enabled.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AnonymousAuthConfig",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for anonymous authentication settings."
        },
        {
          "term": "AnonymousAuthCondition",
          "tier": 1,
          "reasoning": "Named Kubernetes API type that describes conditions for anonymous authentication."
        },
        {
          "term": "apiserver-k8s-io-v1beta1",
          "tier": 1,
          "reasoning": "Kubernetes API group and version identifier for the apiserver configuration."
        },
        {
          "term": "anonymous auth",
          "tier": 2,
          "reasoning": "Domain concept referring to authentication mechanism allowing unauthenticated access."
        },
        {
          "term": "path",
          "tier": 2,
          "reasoning": "Technical field specifying the URL path for which anonymous authentication applies."
        },
        {
          "term": "condition",
          "tier": 2,
          "reasoning": "Domain concept describing a state or requirement that must be met for a feature to be enabled."
        },
        {
          "term": "Field",
          "tier": 3,
          "reasoning": "Technical term referring to a data attribute in an API object specification."
        },
        {
          "term": "v1beta1",
          "tier": 2,
          "reasoning": "API version indicating beta maturity level in Kubernetes API versioning."
        },
        {
          "term": "enabled",
          "tier": 3,
          "reasoning": "Technical state indicating a feature or capability is active."
        },
        {
          "term": "string",
          "tier": 3,
          "reasoning": "Data type specification for the path field value."
        }
      ],
      "term_count": 10,
      "generated_at": "2026-02-08T21:03:32.332301",
      "elapsed_time": 6.287521123886108
    },
    {
      "chunk_id": "tasks_administer-cluster_coredns_sec3",
      "doc_id": "tasks_administer-cluster_coredns",
      "heading": "Upgrading CoreDNS",
      "source_file": "tasks_administer-cluster_coredns.md",
      "content": "You can check the version of CoreDNS that kubeadm installs for each version of\nKubernetes in the page\n[CoreDNS version in Kubernetes](https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md).\n\nCoreDNS can be upgraded manually in case you want to only upgrade CoreDNS\nor use your own custom image.\nThere is a helpful [guideline and walkthrough](https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md)\navailable to ensure a smooth upgrade.\nMake sure the existing CoreDNS configuration (\"Corefile\") is retained when\nupgrading your cluster.\n\nIf you are upgrading your cluster using the `kubeadm` tool, `kubeadm`\ncan take care of retaining the existing CoreDNS configuration automatically.",
      "terms": [
        {
          "term": "CoreDNS",
          "tier": 1,
          "reasoning": "Core Kubernetes DNS component and proper noun for the DNS server used in Kubernetes clusters."
        },
        {
          "term": "kubeadm",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool for cluster bootstrapping and management."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the primary subject domain."
        },
        {
          "term": "Corefile",
          "tier": 1,
          "reasoning": "CoreDNS-specific configuration file name, a proper noun for the configuration resource."
        },
        {
          "term": "CoreDNS configuration",
          "tier": 2,
          "reasoning": "Domain concept referring to the settings and parameters that define CoreDNS behavior."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes architectural concept referring to a set of nodes running containerized applications."
        },
        {
          "term": "upgrade",
          "tier": 2,
          "reasoning": "Technical process of updating software components to newer versions in Kubernetes context."
        },
        {
          "term": "upgrading",
          "tier": 2,
          "reasoning": "Technical process term as it appears in the text describing the update procedure."
        },
        {
          "term": "version",
          "tier": 2,
          "reasoning": "Technical concept referring to specific releases of software components."
        },
        {
          "term": "custom image",
          "tier": 2,
          "reasoning": "Container/Kubernetes concept referring to user-defined container images."
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Core container concept referring to container images used in Kubernetes."
        },
        {
          "term": "configuration",
          "tier": 2,
          "reasoning": "Technical concept for settings and parameters that control system behavior."
        },
        {
          "term": "CoreDNS version",
          "tier": 2,
          "reasoning": "Specific versioning concept for the CoreDNS component within Kubernetes."
        },
        {
          "term": "manually",
          "tier": 3,
          "reasoning": "Operational term describing a non-automated upgrade approach."
        },
        {
          "term": "walkthrough",
          "tier": 3,
          "reasoning": "Documentation/operational term for step-by-step guidance in technical procedures."
        },
        {
          "term": "guideline",
          "tier": 3,
          "reasoning": "Technical documentation term for recommended practices."
        },
        {
          "term": "tool",
          "tier": 3,
          "reasoning": "General technical term referring to CLI utilities like kubeadm."
        }
      ],
      "term_count": 17,
      "generated_at": "2026-02-08T21:03:45.101347",
      "elapsed_time": 11.765461683273315
    },
    {
      "chunk_id": "tasks_debug_debug-application_debug-statefulset_sec1",
      "doc_id": "tasks_debug_debug-application_debug-statefulset",
      "heading": "{{% heading \"prerequisites\" %}}",
      "source_file": "tasks_debug_debug-application_debug-statefulset.md",
      "content": "* You need to have a Kubernetes cluster, and the kubectl command-line tool must be configured to communicate with your cluster.\n* You should have a StatefulSet running that you want to investigate.\n\n<!-- steps -->",
      "terms": [
        {
          "term": "Kubernetes cluster",
          "tier": 1,
          "reasoning": "Core infrastructure resource - a complete Kubernetes deployment environment"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the primary subject of this documentation"
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental architectural concept referring to a set of nodes running containerized applications"
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool for cluster management and communication"
        },
        {
          "term": "command-line tool",
          "tier": 2,
          "reasoning": "Technical term describing the type of interface kubectl provides"
        },
        {
          "term": "configured",
          "tier": 3,
          "reasoning": "Technical process term referring to setting up tool parameters for cluster communication"
        },
        {
          "term": "communicate",
          "tier": 3,
          "reasoning": "Technical term in context referring to API communication between kubectl and cluster"
        },
        {
          "term": "StatefulSet",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/workload resource for managing stateful applications"
        },
        {
          "term": "running",
          "tier": 3,
          "reasoning": "Technical state term describing an active workload in Kubernetes context"
        }
      ],
      "term_count": 9,
      "generated_at": "2026-02-08T21:03:52.701677",
      "elapsed_time": 6.596871376037598
    },
    {
      "chunk_id": "concepts_overview_working-with-objects_annotations_sec1",
      "doc_id": "concepts_overview_working-with-objects_annotations",
      "heading": "Attaching metadata to objects",
      "source_file": "concepts_overview_working-with-objects_annotations.md",
      "content": "You can use either labels or annotations to attach metadata to Kubernetes\nobjects. Labels can be used to select objects and to find\ncollections of objects that satisfy certain conditions. In contrast, annotations\nare not used to identify and select objects. The metadata\nin an annotation can be small or large, structured or unstructured, and can\ninclude characters not permitted by labels. It is possible to use labels as \nwell as annotations in the metadata of the same object.\n\nAnnotations, like labels, are key/value maps:\n\n```json\n\"metadata\": {\n  \"annotations\": {\n    \"key1\" : \"value1\",\n    \"key2\" : \"value2\"\n  }\n}\n```\n\n{{<note>}}\nThe keys and the values in the map must be strings. In other words, you cannot use\nnumeric, boolean, list or other types for either the keys or the values.\n{{</note>}}\n\nHere are some examples of information that could be recorded in annotations:\n\n* Fields managed by a declarative configuration layer. Attaching these fields\n  as annotations distinguishes them from default values set by clients or\n  servers, and from auto-generated fields and fields set by\n  auto-sizing or auto-scaling systems.\n\n* Build, release, or image information like timestamps, release IDs, git branch,\n  PR numbers, image hashes, and registry address.\n\n* Pointers to logging, monitoring, analytics, or audit repositories.\n\n* Client library or tool information that can be used for debugging purposes:\n  for example, name, version, and build information.\n\n* User or tool/system provenance information, such as URLs of related objects\n  from other ecosystem components.\n\n* Lightweight rollout tool metadata: for example, config or checkpoints.\n\n* Phone or pager numbers of persons responsible, or directory entries that\n  specify where that information can be found, such as a team web site.\n\n* Directives from the end-user to the implementations to modify behavior or\n  engage non-standard features.\n\nInstead of using annotations, you could store this type of information in an\nexternal database or directory, but that would make it much harder to produce\nshared client libraries and tools for deployment, management, introspection,\nand the like.",
      "terms": [
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for attaching metadata to objects for selection and identification"
        },
        {
          "term": "annotations",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for attaching non-identifying metadata to objects"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Technical concept referring to data about Kubernetes objects"
        },
        {
          "term": "key/value maps",
          "tier": 3,
          "reasoning": "Data structure concept describing how annotations and labels are stored"
        },
        {
          "term": "strings",
          "tier": 3,
          "reasoning": "Data type constraint for annotation keys and values"
        },
        {
          "term": "declarative configuration layer",
          "tier": 2,
          "reasoning": "Architectural concept describing configuration management approach in Kubernetes"
        },
        {
          "term": "clients",
          "tier": 3,
          "reasoning": "Technical term referring to systems that interact with Kubernetes API"
        },
        {
          "term": "servers",
          "tier": 3,
          "reasoning": "Technical term referring to systems that serve Kubernetes API"
        },
        {
          "term": "auto-generated fields",
          "tier": 2,
          "reasoning": "Domain concept for fields automatically created by Kubernetes"
        },
        {
          "term": "auto-sizing",
          "tier": 2,
          "reasoning": "Domain concept for automatic resource sizing systems"
        },
        {
          "term": "auto-scaling systems",
          "tier": 2,
          "reasoning": "Domain concept for systems that automatically scale resources"
        },
        {
          "term": "release IDs",
          "tier": 3,
          "reasoning": "Technical metadata concept for identifying software releases"
        },
        {
          "term": "git branch",
          "tier": 3,
          "reasoning": "Version control concept used in build metadata"
        },
        {
          "term": "PR numbers",
          "tier": 3,
          "reasoning": "Pull request identifiers used in build metadata"
        },
        {
          "term": "image hashes",
          "tier": 2,
          "reasoning": "Container image identification concept"
        },
        {
          "term": "registry address",
          "tier": 2,
          "reasoning": "Container registry location concept"
        },
        {
          "term": "logging",
          "tier": 2,
          "reasoning": "Observability concept for recording system events"
        },
        {
          "term": "monitoring",
          "tier": 2,
          "reasoning": "Observability concept for tracking system health"
        },
        {
          "term": "analytics",
          "tier": 2,
          "reasoning": "Observability concept for analyzing system data"
        },
        {
          "term": "audit repositories",
          "tier": 2,
          "reasoning": "Security/compliance concept for storing audit data"
        },
        {
          "term": "client library",
          "tier": 3,
          "reasoning": "Technical term for SDK/libraries interacting with Kubernetes"
        },
        {
          "term": "debugging",
          "tier": 3,
          "reasoning": "Technical process for troubleshooting issues"
        },
        {
          "term": "provenance information",
          "tier": 2,
          "reasoning": "Domain concept for tracking origin and history of resources"
        },
        {
          "term": "ecosystem components",
          "tier": 2,
          "reasoning": "Architectural term for related systems in Kubernetes ecosystem"
        },
        {
          "term": "rollout tool",
          "tier": 2,
          "reasoning": "Deployment concept for tools managing application rollouts"
        },
        {
          "term": "config",
          "tier": 3,
          "reasoning": "Technical shorthand for configuration data"
        },
        {
          "term": "checkpoints",
          "tier": 2,
          "reasoning": "Technical concept for saving state during rollouts"
        },
        {
          "term": "deployment",
          "tier": 2,
          "reasoning": "Domain concept for deploying applications (used in context of management)"
        },
        {
          "term": "management",
          "tier": 3,
          "reasoning": "Operational concept for administering Kubernetes resources"
        },
        {
          "term": "introspection",
          "tier": 2,
          "reasoning": "Technical concept for examining system state"
        },
        {
          "term": "external database",
          "tier": 3,
          "reasoning": "Infrastructure concept for storing data outside Kubernetes"
        },
        {
          "term": "directory",
          "tier": 3,
          "reasoning": "Technical concept for external data storage systems"
        },
        {
          "term": "shared client libraries",
          "tier": 2,
          "reasoning": "Technical concept for reusable code libraries across tools"
        },
        {
          "term": "timestamps",
          "tier": 3,
          "reasoning": "Technical metadata concept for recording time information"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container image concept used in build information context"
        }
      ],
      "term_count": 35,
      "generated_at": "2026-02-08T21:04:09.821062",
      "elapsed_time": 16.114391326904297
    },
    {
      "chunk_id": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster_sec7",
      "doc_id": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster",
      "heading": "{{% heading \"whatsnext\" %}}",
      "source_file": "tasks_configure-pod-container_assign-resources_set-up-dra-cluster.md",
      "content": "* [Learn more about DRA](/docs/concepts/scheduling-eviction/dynamic-resource-allocation)\n* [Allocate Devices to Workloads with DRA](/docs/tasks/configure-pod-container/assign-resources/allocate-devices-dra)",
      "terms": [
        {
          "term": "DRA",
          "tier": 1,
          "reasoning": "Abbreviation for Dynamic Resource Allocation, a specific Kubernetes feature/API for resource management."
        },
        {
          "term": "Dynamic Resource Allocation",
          "tier": 1,
          "reasoning": "Implied by the DRA abbreviation in the URL path, this is a core Kubernetes scheduling feature."
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Domain concept appearing in the URL path 'scheduling-eviction', referring to the Kubernetes scheduling process."
        },
        {
          "term": "eviction",
          "tier": 2,
          "reasoning": "Domain concept appearing in the URL path 'scheduling-eviction', referring to the process of removing pods from nodes."
        },
        {
          "term": "Devices",
          "tier": 2,
          "reasoning": "Technical term in Kubernetes context referring to hardware resources that can be allocated to workloads."
        },
        {
          "term": "Workloads",
          "tier": 2,
          "reasoning": "Domain concept referring to applications or jobs running in Kubernetes that consume resources."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Core Kubernetes API object implied by 'configure-pod-container' in the URL path."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept appearing in the URL path 'configure-pod-container'."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Technical term appearing in 'assign-resources' and 'Dynamic Resource Allocation', referring to compute resources in Kubernetes."
        },
        {
          "term": "Allocate",
          "tier": 2,
          "reasoning": "Technical process term describing the action of assigning resources to workloads in Kubernetes."
        },
        {
          "term": "allocate-devices-dra",
          "tier": 3,
          "reasoning": "Specific documentation path/task identifier for device allocation using DRA."
        }
      ],
      "term_count": 11,
      "generated_at": "2026-02-08T21:04:18.811528",
      "elapsed_time": 7.9841883182525635
    },
    {
      "chunk_id": "reference_config-api_apiserver-admission.v1_sec2",
      "doc_id": "reference_config-api_apiserver-admission.v1",
      "heading": "`AdmissionResponse`     {#admission-k8s-io-v1-AdmissionResponse}",
      "source_file": "reference_config-api_apiserver-admission.v1.md",
      "content": "**Appears in:**\n\n- [AdmissionReview](#admission-k8s-io-v1-AdmissionReview)\n\n\n<p>AdmissionResponse describes an admission response.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>uid</code> <B>[Required]</B><br/>\n<a href=\"https://pkg.go.dev/k8s.io/apimachinery/pkg/types#UID\"><code>k8s.io/apimachinery/pkg/types.UID</code></a>\n</td>\n<td>\n   <p>uid is an identifier for the individual request/response.\nThis must be copied over from the corresponding AdmissionRequest.</p>\n</td>\n</tr>\n<tr><td><code>allowed</code> <B>[Required]</B><br/>\n<code>bool</code>\n</td>\n<td>\n   <p>allowed indicates whether or not the admission request was permitted.</p>\n</td>\n</tr>\n<tr><td><code>status</code><br/>\n<a href=\"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.35/#status-v1-meta\"><code>meta/v1.Status</code></a>\n</td>\n<td>\n   <p>status is the result contains extra details into why an admission request was denied.\nThis field IS NOT consulted in any way if &quot;Allowed&quot; is &quot;true&quot;.</p>\n</td>\n</tr>\n<tr><td><code>patch</code><br/>\n<code>[]byte</code>\n</td>\n<td>\n   <p>patch is the patch body. Currently we only support &quot;JSONPatch&quot; which implements RFC 6902.</p>\n</td>\n</tr>\n<tr><td><code>patchType</code><br/>\n<a href=\"#admission-k8s-io-v1-PatchType\"><code>PatchType</code></a>\n</td>\n<td>\n   <p>patchType is the type of Patch. Currently we only allow &quot;JSONPatch&quot;.</p>\n</td>\n</tr>\n<tr><td><code>auditAnnotations</code><br/>\n<code>map[string]string</code>\n</td>\n<td>\n   <p>auditAnnotations is an unstructured key value map set by remote admission controller (e.g. error=image-blacklisted).\nMutatingAdmissionWebhook and ValidatingAdmissionWebhook admission controller will prefix the keys with\nadmission webhook name (e.g. imagepolicy.example.com/error=image-blacklisted). AuditAnnotations will be provided by\nthe admission webhook to add additional context to the audit log for this request.</p>\n</td>\n</tr>\n<tr><td><code>warnings</code><br/>\n<code>[]string</code>\n</td>\n<td>\n   <p>warnings is a list of warning messages to return to the requesting API client.\nWarning messages describe a problem the client making the API request should correct or be aware of.\nLimit warnings to 120 characters if possible.\nWarnings over 256 characters and large numbers of warnings may be truncated.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "AdmissionReview",
          "tier": 1,
          "reasoning": "Kubernetes API object for admission control review requests and responses."
        },
        {
          "term": "AdmissionResponse",
          "tier": 1,
          "reasoning": "Kubernetes API object that describes an admission response structure."
        },
        {
          "term": "AdmissionRequest",
          "tier": 1,
          "reasoning": "Kubernetes API object representing an admission request that AdmissionResponse corresponds to."
        },
        {
          "term": "uid",
          "tier": 2,
          "reasoning": "Field identifier for individual request/response tracking in admission control."
        },
        {
          "term": "UID",
          "tier": 2,
          "reasoning": "Type reference from k8s.io/apimachinery for unique identifiers."
        },
        {
          "term": "k8s.io/apimachinery/pkg/types.UID",
          "tier": 1,
          "reasoning": "Full package path reference to the UID type in Kubernetes apimachinery."
        },
        {
          "term": "allowed",
          "tier": 2,
          "reasoning": "Boolean field indicating whether an admission request was permitted."
        },
        {
          "term": "status",
          "tier": 2,
          "reasoning": "Field containing extra details about why an admission request was denied."
        },
        {
          "term": "meta/v1.Status",
          "tier": 1,
          "reasoning": "Kubernetes API type reference for status information in meta/v1 API group."
        },
        {
          "term": "patch",
          "tier": 2,
          "reasoning": "Field containing the patch body for mutating admission responses."
        },
        {
          "term": "JSONPatch",
          "tier": 2,
          "reasoning": "Patch format implementing RFC 6902 for JSON document modifications."
        },
        {
          "term": "RFC 6902",
          "tier": 3,
          "reasoning": "Internet standard specification for JSON Patch operations."
        },
        {
          "term": "patchType",
          "tier": 2,
          "reasoning": "Field specifying the type of patch being applied in admission response."
        },
        {
          "term": "PatchType",
          "tier": 1,
          "reasoning": "Kubernetes API type for specifying patch format in admission control."
        },
        {
          "term": "auditAnnotations",
          "tier": 2,
          "reasoning": "Key-value map for adding context to audit logs from admission controllers."
        },
        {
          "term": "audit log",
          "tier": 2,
          "reasoning": "Kubernetes logging mechanism for recording API request details."
        },
        {
          "term": "remote admission controller",
          "tier": 2,
          "reasoning": "External webhook-based admission controller processing requests."
        },
        {
          "term": "admission controller",
          "tier": 2,
          "reasoning": "Kubernetes component that intercepts and validates/mutates API requests."
        },
        {
          "term": "MutatingAdmissionWebhook",
          "tier": 1,
          "reasoning": "Kubernetes admission controller type that can modify incoming API requests."
        },
        {
          "term": "ValidatingAdmissionWebhook",
          "tier": 1,
          "reasoning": "Kubernetes admission controller type that validates incoming API requests."
        },
        {
          "term": "admission webhook",
          "tier": 2,
          "reasoning": "HTTP callback mechanism for external admission control logic."
        },
        {
          "term": "warnings",
          "tier": 2,
          "reasoning": "Field containing warning messages returned to API clients about request issues."
        },
        {
          "term": "API client",
          "tier": 2,
          "reasoning": "Client making requests to the Kubernetes API server."
        },
        {
          "term": "admission request",
          "tier": 2,
          "reasoning": "Request sent to admission controllers for validation or mutation."
        },
        {
          "term": "admission-k8s-io-v1-AdmissionReview",
          "tier": 1,
          "reasoning": "Full API reference identifier for AdmissionReview in admission.k8s.io/v1."
        },
        {
          "term": "admission-k8s-io-v1-PatchType",
          "tier": 1,
          "reasoning": "Full API reference identifier for PatchType in admission.k8s.io/v1."
        },
        {
          "term": "bool",
          "tier": 3,
          "reasoning": "Boolean data type used for the allowed field."
        },
        {
          "term": "[]byte",
          "tier": 3,
          "reasoning": "Go byte slice type used for patch body data."
        },
        {
          "term": "map[string]string",
          "tier": 3,
          "reasoning": "Go map type used for auditAnnotations key-value pairs."
        },
        {
          "term": "[]string",
          "tier": 3,
          "reasoning": "Go string slice type used for warnings list."
        }
      ],
      "term_count": 30,
      "generated_at": "2026-02-08T21:04:40.193970",
      "elapsed_time": 20.378008365631104
    },
    {
      "chunk_id": "tasks_run-application_configure-pdb_sec1",
      "doc_id": "tasks_run-application_configure-pdb",
      "heading": "{{% heading \"prerequisites\" %}}",
      "source_file": "tasks_run-application_configure-pdb.md",
      "content": "{{< version-check >}}\n\n- You are the owner of an application running on a Kubernetes cluster that requires\n  high availability.\n- You should know how to deploy [Replicated Stateless Applications](/docs/tasks/run-application/run-stateless-application-deployment/)\n  and/or [Replicated Stateful Applications](/docs/tasks/run-application/run-replicated-stateful-application/).\n- You should have read about [Pod Disruptions](/docs/concepts/workloads/pods/disruptions/).\n- You should confirm with your cluster owner or service provider that they respect\n  Pod Disruption Budgets.\n\n<!-- steps -->",
      "terms": [
        {
          "term": "Kubernetes cluster",
          "tier": 1,
          "reasoning": "Core infrastructure resource - the primary container orchestration platform being discussed."
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The container orchestration platform that is the central subject of this documentation."
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Fundamental architectural concept referring to a set of nodes running containerized applications."
        },
        {
          "term": "high availability",
          "tier": 2,
          "reasoning": "Critical architectural concept describing system design for continuous operation."
        },
        {
          "term": "application",
          "tier": 2,
          "reasoning": "Technical term referring to workloads running on the cluster."
        },
        {
          "term": "Replicated Stateless Applications",
          "tier": 1,
          "reasoning": "Specific Kubernetes workload pattern and documentation reference for applications without persistent state."
        },
        {
          "term": "Replicated Stateful Applications",
          "tier": 1,
          "reasoning": "Specific Kubernetes workload pattern for applications that maintain persistent state."
        },
        {
          "term": "Stateless Applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications that don't maintain state between requests."
        },
        {
          "term": "Stateful Applications",
          "tier": 2,
          "reasoning": "Domain concept describing applications that maintain persistent state."
        },
        {
          "term": "Pod Disruptions",
          "tier": 1,
          "reasoning": "Core Kubernetes concept referring to events that cause Pods to become unavailable."
        },
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Fundamental Kubernetes API object - the smallest deployable unit."
        },
        {
          "term": "Pod Disruption Budgets",
          "tier": 1,
          "reasoning": "Specific Kubernetes API resource (PDB) that limits voluntary disruptions to Pods."
        },
        {
          "term": "cluster owner",
          "tier": 2,
          "reasoning": "Role-based term describing the administrator responsible for cluster management."
        },
        {
          "term": "service provider",
          "tier": 2,
          "reasoning": "Technical role term referring to entities providing Kubernetes infrastructure services."
        },
        {
          "term": "deploy",
          "tier": 2,
          "reasoning": "Core operational process for releasing applications to a cluster."
        },
        {
          "term": "owner",
          "tier": 3,
          "reasoning": "Contextual term referring to the entity responsible for an application workload."
        }
      ],
      "term_count": 16,
      "generated_at": "2026-02-08T21:04:50.506896",
      "elapsed_time": 9.308373212814331
    },
    {
      "chunk_id": "tasks_inject-data-application_downward-api-volume-expose-pod-information_sec2",
      "doc_id": "tasks_inject-data-application_downward-api-volume-expose-pod-information",
      "heading": "Store container fields",
      "source_file": "tasks_inject-data-application_downward-api-volume-expose-pod-information.md",
      "content": "The preceding exercise, you made Pod-level fields accessible using the\ndownward API.\nIn this next exercise, you are going to pass fields that are part of the Pod\ndefinition, but taken from the specific\n[container](/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container)\nrather than from the Pod overall. Here is a manifest for a Pod that again has\njust one container:\n\n{{% code_sample file=\"pods/inject/dapi-volume-resources.yaml\" %}}\n\nIn the manifest, you can see that the Pod has a\n[`downwardAPI` volume](/docs/concepts/storage/volumes/#downwardapi),\nand that the single container in that Pod mounts the volume at `/etc/podinfo`.\n\nLook at the `items` array under `downwardAPI`. Each element of the array\ndefines a file in the downward API volume.\n\nThe first element specifies that in the container named `client-container`,\nthe value of the `limits.cpu` field in the format specified by `1m` should be\npublished as a file named `cpu_limit`. The `divisor` field is optional and has the\ndefault value of `1`. A divisor of 1 means cores for `cpu` resources, or\nbytes for `memory` resources.\n\nCreate the Pod:\n\n```shell\nkubectl apply -f https://k8s.io/examples/pods/inject/dapi-volume-resources.yaml\n```\n\nGet a shell into the container that is running in your Pod:\n\n```shell\nkubectl exec -it kubernetes-downwardapi-volume-example-2 -- sh\n```\n\nIn your shell, view the `cpu_limit` file:\n\n```shell",
      "terms": [
        {
          "term": "Pod",
          "tier": 1,
          "reasoning": "Core Kubernetes API object and workload resource explicitly discussed throughout the chunk."
        },
        {
          "term": "downward API",
          "tier": 1,
          "reasoning": "Specific Kubernetes feature for exposing Pod and container information to containers."
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept representing the runtime unit within a Pod."
        },
        {
          "term": "Pod-level fields",
          "tier": 2,
          "reasoning": "Technical concept referring to metadata and spec fields defined at the Pod scope."
        },
        {
          "term": "manifest",
          "tier": 2,
          "reasoning": "Technical term for the YAML/JSON file that declares Kubernetes resources."
        },
        {
          "term": "downwardAPI volume",
          "tier": 1,
          "reasoning": "Specific Kubernetes volume type that exposes Pod/container information as files."
        },
        {
          "term": "volume",
          "tier": 2,
          "reasoning": "Core Kubernetes storage concept for providing persistent or ephemeral storage to containers."
        },
        {
          "term": "client-container",
          "tier": 1,
          "reasoning": "Specific container name referenced in the example manifest."
        },
        {
          "term": "limits.cpu",
          "tier": 2,
          "reasoning": "Kubernetes resource field specifying CPU resource limits for a container."
        },
        {
          "term": "divisor",
          "tier": 2,
          "reasoning": "Technical field in downward API configuration that specifies unit conversion."
        },
        {
          "term": "cpu",
          "tier": 3,
          "reasoning": "Computing resource type managed by Kubernetes resource limits and requests."
        },
        {
          "term": "memory",
          "tier": 3,
          "reasoning": "Computing resource type managed by Kubernetes resource limits and requests."
        },
        {
          "term": "cores",
          "tier": 3,
          "reasoning": "Unit of CPU measurement referenced in the context of resource divisors."
        },
        {
          "term": "bytes",
          "tier": 3,
          "reasoning": "Unit of memory measurement referenced in the context of resource divisors."
        },
        {
          "term": "kubectl apply",
          "tier": 1,
          "reasoning": "Kubernetes CLI command for creating or updating resources declaratively."
        },
        {
          "term": "kubectl exec",
          "tier": 1,
          "reasoning": "Kubernetes CLI command for executing commands inside a container."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes command-line interface tool."
        },
        {
          "term": "shell",
          "tier": 3,
          "reasoning": "Command-line interface context for interacting with containers."
        },
        {
          "term": "cpu_limit",
          "tier": 2,
          "reasoning": "Specific file name created by downward API to expose CPU limit information."
        },
        {
          "term": "kubernetes-downwardapi-volume-example-2",
          "tier": 1,
          "reasoning": "Specific Pod name used in the example commands."
        },
        {
          "term": "mounts",
          "tier": 2,
          "reasoning": "Technical term for attaching volumes to container filesystem paths."
        },
        {
          "term": "/etc/podinfo",
          "tier": 2,
          "reasoning": "Specific mount path where downward API volume is attached in the example."
        },
        {
          "term": "1m",
          "tier": 2,
          "reasoning": "Kubernetes resource quantity format representing millicores for CPU."
        },
        {
          "term": "file",
          "tier": 3,
          "reasoning": "Filesystem object created by downward API volume to expose information."
        },
        {
          "term": "resources",
          "tier": 2,
          "reasoning": "Kubernetes concept for CPU and memory allocations to containers."
        }
      ],
      "term_count": 25,
      "generated_at": "2026-02-08T21:05:06.267972",
      "elapsed_time": 14.756489276885986
    },
    {
      "chunk_id": "tasks_manage-kubernetes-objects_kustomization_sec10",
      "doc_id": "tasks_manage-kubernetes-objects_kustomization",
      "heading": "Create a deployment.yaml file",
      "source_file": "tasks_manage-kubernetes-objects_kustomization.md",
      "content": "cat <<EOF > deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-nginx\nspec:\n  selector:\n    matchLabels:\n      run: my-nginx\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        run: my-nginx\n    spec:\n      containers:\n      - name: my-nginx\n        image: nginx\n        ports:\n        - containerPort: 80\nEOF",
      "terms": [
        {
          "term": "Deployment",
          "tier": 1,
          "reasoning": "Core Kubernetes API object/resource for managing replicated applications"
        },
        {
          "term": "apiVersion",
          "tier": 2,
          "reasoning": "Kubernetes manifest field specifying the API version for the resource"
        },
        {
          "term": "apps/v1",
          "tier": 2,
          "reasoning": "Specific Kubernetes API group and version for workload resources like Deployments"
        },
        {
          "term": "kind",
          "tier": 2,
          "reasoning": "Kubernetes manifest field that specifies the type of resource being defined"
        },
        {
          "term": "metadata",
          "tier": 2,
          "reasoning": "Kubernetes manifest section containing identifying information about the resource"
        },
        {
          "term": "name",
          "tier": 3,
          "reasoning": "Kubernetes metadata field used to identify resources within a namespace"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes manifest section defining the desired state specification of a resource"
        },
        {
          "term": "selector",
          "tier": 2,
          "reasoning": "Kubernetes field used to identify which Pods a controller should manage"
        },
        {
          "term": "matchLabels",
          "tier": 2,
          "reasoning": "Kubernetes selector type that matches resources based on exact label key-value pairs"
        },
        {
          "term": "replicas",
          "tier": 2,
          "reasoning": "Kubernetes Deployment field specifying the desired number of Pod instances"
        },
        {
          "term": "template",
          "tier": 2,
          "reasoning": "Kubernetes Pod template specification embedded within a Deployment"
        },
        {
          "term": "labels",
          "tier": 2,
          "reasoning": "Kubernetes metadata key-value pairs used for organizing and selecting resources"
        },
        {
          "term": "containers",
          "tier": 2,
          "reasoning": "Kubernetes Pod spec field defining the container(s) to run in the Pod"
        },
        {
          "term": "container",
          "tier": 2,
          "reasoning": "Core virtualization concept - isolated runtime environment for applications"
        },
        {
          "term": "image",
          "tier": 2,
          "reasoning": "Container image reference specifying the packaged application to run"
        },
        {
          "term": "nginx",
          "tier": 1,
          "reasoning": "Specific container image name - a well-known web server/reverse proxy"
        },
        {
          "term": "ports",
          "tier": 2,
          "reasoning": "Kubernetes container spec field defining network port configurations"
        },
        {
          "term": "containerPort",
          "tier": 2,
          "reasoning": "Kubernetes field specifying the port number exposed by a container"
        },
        {
          "term": "EOF",
          "tier": 3,
          "reasoning": "Shell heredoc delimiter used in bash/shell scripting for multi-line input"
        },
        {
          "term": "cat",
          "tier": 3,
          "reasoning": "Unix/Linux command used here to create a file from heredoc input"
        },
        {
          "term": "YAML",
          "tier": 3,
          "reasoning": "Data serialization format used for Kubernetes manifest files (implicit in deployment.yaml)"
        },
        {
          "term": "deployment.yaml",
          "tier": 3,
          "reasoning": "Kubernetes manifest file name following naming conventions for Deployment resources"
        },
        {
          "term": "my-nginx",
          "tier": 3,
          "reasoning": "Resource name and label value used to identify this specific Deployment and its Pods"
        },
        {
          "term": "run",
          "tier": 3,
          "reasoning": "Label key used in this manifest for Pod selection and identification"
        }
      ],
      "term_count": 24,
      "generated_at": "2026-02-08T21:05:21.485212",
      "elapsed_time": 14.211526870727539
    },
    {
      "chunk_id": "reference_node_node-status_sec3",
      "doc_id": "reference_node_node-status",
      "heading": "Conditions {#condition}",
      "source_file": "reference_node_node-status.md",
      "content": "The `conditions` field describes the status of all `Running` nodes. Examples of conditions include:\n\n{{< table caption = \"Node conditions, and a description of when each condition applies.\" >}}\n| Node Condition       | Description |\n|----------------------|-------------|\n| `Ready`              | `True` if the node is healthy and ready to accept pods, `False` if the node is not healthy and is not accepting pods, and `Unknown` if the node controller has not heard from the node in the last `node-monitor-grace-period` (default is 50 seconds) |\n| `DiskPressure`       | `True` if pressure exists on the disk size\u2014that is, if the disk capacity is low; otherwise `False` |\n| `MemoryPressure`     | `True` if pressure exists on the node memory\u2014that is, if the node memory is low; otherwise `False` |\n| `PIDPressure`        | `True` if pressure exists on the processes\u2014that is, if there are too many processes on the node; otherwise `False` |\n| `NetworkUnavailable` | `True` if the network for the node is not correctly configured, otherwise `False` |\n{{< /table >}}\n\n{{< note >}}\nIf you use command-line tools to print details of a cordoned Node, the Condition includes\n`SchedulingDisabled`. `SchedulingDisabled` is not a Condition in the Kubernetes API; instead,\ncordoned nodes are marked Unschedulable in their spec.\n{{< /note >}}\n\nIn the Kubernetes API, a node's condition is represented as part of the `.status`\nof the Node resource. For example, the following JSON structure describes a healthy node:\n\n```json\n\"conditions\": [\n  {\n    \"type\": \"Ready\",\n    \"status\": \"True\",\n    \"reason\": \"KubeletReady\",\n    \"message\": \"kubelet is posting ready status\",\n    \"lastHeartbeatTime\": \"2019-06-05T18:38:35Z\",\n    \"lastTransitionTime\": \"2019-06-05T11:41:27Z\"\n  }\n]\n```\n\nWhen problems occur on nodes, the Kubernetes control plane automatically creates\n[taints](/docs/concepts/scheduling-eviction/taint-and-toleration/) that match the conditions\naffecting the node. An example of this is when the `status` of the Ready condition\nremains `Unknown` or `False` for longer than the kube-controller-manager's `NodeMonitorGracePeriod`,\nwhich defaults to 50 seconds. This will cause either an `node.kubernetes.io/unreachable` taint, for an `Unknown` status,\nor a `node.kubernetes.io/not-ready` taint, for a `False` status, to be added to the Node.\n\nThese taints affect pending pods as the scheduler takes the Node's taints into consideration when\nassigning a pod to a Node. Existing pods scheduled to the node may be evicted due to the application\nof `NoExecute` taints. Pods may also have {{< glossary_tooltip text=\"tolerations\" term_id=\"toleration\" >}} that let\nthem schedule to and continue running on a Node even though it has a specific taint.\n\nSee [Taint Based Evictions](/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-based-evictions) and\n[Taint Nodes by Condition](/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition)\nfor more details.",
      "terms": [
        {
          "term": "conditions",
          "tier": 2,
          "reasoning": "Domain concept describing the status field of node resources in Kubernetes API"
        },
        {
          "term": "Running",
          "tier": 2,
          "reasoning": "Node status state indicating operational nodes"
        },
        {
          "term": "nodes",
          "tier": 2,
          "reasoning": "Core Kubernetes concept representing worker machines in a cluster"
        },
        {
          "term": "Node Condition",
          "tier": 2,
          "reasoning": "Specific Kubernetes concept for describing node health states"
        },
        {
          "term": "Ready",
          "tier": 1,
          "reasoning": "Named node condition type in Kubernetes API"
        },
        {
          "term": "DiskPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating low disk capacity"
        },
        {
          "term": "MemoryPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating low node memory"
        },
        {
          "term": "PIDPressure",
          "tier": 1,
          "reasoning": "Named node condition type indicating too many processes"
        },
        {
          "term": "NetworkUnavailable",
          "tier": 1,
          "reasoning": "Named node condition type indicating network misconfiguration"
        },
        {
          "term": "pods",
          "tier": 1,
          "reasoning": "Core Kubernetes API resource representing deployable units"
        },
        {
          "term": "node controller",
          "tier": 1,
          "reasoning": "Kubernetes control plane component managing node lifecycle"
        },
        {
          "term": "node-monitor-grace-period",
          "tier": 1,
          "reasoning": "Specific configuration parameter for node monitoring timeout"
        },
        {
          "term": "disk capacity",
          "tier": 3,
          "reasoning": "Technical term for storage space relevant to DiskPressure condition"
        },
        {
          "term": "node memory",
          "tier": 2,
          "reasoning": "Technical concept for memory resources on a node"
        },
        {
          "term": "processes",
          "tier": 3,
          "reasoning": "OS-level concept relevant to PIDPressure condition"
        },
        {
          "term": "network",
          "tier": 3,
          "reasoning": "Infrastructure concept relevant to NetworkUnavailable condition"
        },
        {
          "term": "cordoned Node",
          "tier": 2,
          "reasoning": "Kubernetes operational concept for nodes marked to prevent new pod scheduling"
        },
        {
          "term": "SchedulingDisabled",
          "tier": 1,
          "reasoning": "Condition label shown in CLI for cordoned nodes"
        },
        {
          "term": "Kubernetes API",
          "tier": 1,
          "reasoning": "Core interface for interacting with Kubernetes resources"
        },
        {
          "term": "Unschedulable",
          "tier": 2,
          "reasoning": "Node spec field marking nodes as unavailable for scheduling"
        },
        {
          "term": "spec",
          "tier": 2,
          "reasoning": "Kubernetes resource specification field"
        },
        {
          "term": ".status",
          "tier": 2,
          "reasoning": "Kubernetes resource status field containing runtime state"
        },
        {
          "term": "Node resource",
          "tier": 1,
          "reasoning": "Kubernetes API object representing a cluster node"
        },
        {
          "term": "type",
          "tier": 2,
          "reasoning": "Field in condition structure identifying the condition kind"
        },
        {
          "term": "status",
          "tier": 2,
          "reasoning": "Field in condition structure indicating True/False/Unknown state"
        },
        {
          "term": "reason",
          "tier": 2,
          "reasoning": "Field in condition structure providing machine-readable cause"
        },
        {
          "term": "message",
          "tier": 2,
          "reasoning": "Field in condition structure providing human-readable description"
        },
        {
          "term": "lastHeartbeatTime",
          "tier": 2,
          "reasoning": "Condition field tracking last node heartbeat timestamp"
        },
        {
          "term": "lastTransitionTime",
          "tier": 2,
          "reasoning": "Condition field tracking when condition last changed"
        },
        {
          "term": "KubeletReady",
          "tier": 1,
          "reasoning": "Specific reason value indicating kubelet is operational"
        },
        {
          "term": "kubelet",
          "tier": 1,
          "reasoning": "Core Kubernetes node agent component"
        },
        {
          "term": "control plane",
          "tier": 2,
          "reasoning": "Kubernetes architectural concept for cluster management components"
        },
        {
          "term": "taints",
          "tier": 2,
          "reasoning": "Kubernetes scheduling mechanism to repel pods from nodes"
        },
        {
          "term": "kube-controller-manager",
          "tier": 1,
          "reasoning": "Core Kubernetes control plane component running controllers"
        },
        {
          "term": "NodeMonitorGracePeriod",
          "tier": 1,
          "reasoning": "Specific kube-controller-manager configuration parameter"
        },
        {
          "term": "node.kubernetes.io/unreachable",
          "tier": 1,
          "reasoning": "Specific taint key applied when node status is Unknown"
        },
        {
          "term": "node.kubernetes.io/not-ready",
          "tier": 1,
          "reasoning": "Specific taint key applied when node status is False"
        },
        {
          "term": "Unknown",
          "tier": 2,
          "reasoning": "Condition status value indicating uncertain node state"
        },
        {
          "term": "False",
          "tier": 2,
          "reasoning": "Condition status value indicating negative/unhealthy state"
        },
        {
          "term": "True",
          "tier": 2,
          "reasoning": "Condition status value indicating positive/healthy state"
        },
        {
          "term": "pending pods",
          "tier": 2,
          "reasoning": "Pods waiting to be scheduled to a node"
        },
        {
          "term": "scheduler",
          "tier": 1,
          "reasoning": "Kubernetes control plane component assigning pods to nodes"
        },
        {
          "term": "evicted",
          "tier": 2,
          "reasoning": "Process of removing pods from nodes"
        },
        {
          "term": "NoExecute",
          "tier": 1,
          "reasoning": "Taint effect that evicts existing pods and prevents new scheduling"
        },
        {
          "term": "tolerations",
          "tier": 2,
          "reasoning": "Pod specification allowing scheduling on tainted nodes"
        },
        {
          "term": "toleration",
          "tier": 2,
          "reasoning": "Singular form of tolerations concept"
        },
        {
          "term": "taint",
          "tier": 2,
          "reasoning": "Singular form of taints scheduling mechanism"
        },
        {
          "term": "Taint Based Evictions",
          "tier": 2,
          "reasoning": "Kubernetes concept for evicting pods based on node taints"
        },
        {
          "term": "Taint Nodes by Condition",
          "tier": 2,
          "reasoning": "Kubernetes feature automatically tainting nodes based on conditions"
        },
        {
          "term": "scheduling",
          "tier": 2,
          "reasoning": "Core Kubernetes process of assigning pods to nodes"
        }
      ],
      "term_count": 50,
      "generated_at": "2026-02-08T21:05:46.314521",
      "elapsed_time": 23.823687314987183
    },
    {
      "chunk_id": "reference_config-api_apiserver-config.v1_sec21",
      "doc_id": "reference_config-api_apiserver-config.v1",
      "heading": "`ProviderConfiguration`     {#apiserver-config-k8s-io-v1-ProviderConfiguration}",
      "source_file": "reference_config-api_apiserver-config.v1.md",
      "content": "**Appears in:**\n\n- [ResourceConfiguration](#apiserver-config-k8s-io-v1-ResourceConfiguration)\n\n\n<p>ProviderConfiguration stores the provided configuration for an encryption provider.</p>\n\n\n<table class=\"table\">\n<thead><tr><th width=\"30%\">Field</th><th>Description</th></tr></thead>\n<tbody>\n    \n  \n<tr><td><code>aesgcm</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-AESConfiguration\"><code>AESConfiguration</code></a>\n</td>\n<td>\n   <p>aesgcm is the configuration for the AES-GCM transformer.</p>\n</td>\n</tr>\n<tr><td><code>aescbc</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-AESConfiguration\"><code>AESConfiguration</code></a>\n</td>\n<td>\n   <p>aescbc is the configuration for the AES-CBC transformer.</p>\n</td>\n</tr>\n<tr><td><code>secretbox</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-SecretboxConfiguration\"><code>SecretboxConfiguration</code></a>\n</td>\n<td>\n   <p>secretbox is the configuration for the Secretbox based transformer.</p>\n</td>\n</tr>\n<tr><td><code>identity</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-IdentityConfiguration\"><code>IdentityConfiguration</code></a>\n</td>\n<td>\n   <p>identity is the (empty) configuration for the identity transformer.</p>\n</td>\n</tr>\n<tr><td><code>kms</code> <B>[Required]</B><br/>\n<a href=\"#apiserver-config-k8s-io-v1-KMSConfiguration\"><code>KMSConfiguration</code></a>\n</td>\n<td>\n   <p>kms contains the name, cache size and path to configuration file for a KMS based envelope transformer.</p>\n</td>\n</tr>\n</tbody>\n</table>",
      "terms": [
        {
          "term": "ResourceConfiguration",
          "tier": 1,
          "reasoning": "Named Kubernetes API configuration object for resource settings."
        },
        {
          "term": "ProviderConfiguration",
          "tier": 1,
          "reasoning": "Named configuration structure that stores encryption provider settings."
        },
        {
          "term": "AESConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for AES-based encryption transformers."
        },
        {
          "term": "SecretboxConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for Secretbox-based encryption transformer."
        },
        {
          "term": "IdentityConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for the identity transformer."
        },
        {
          "term": "KMSConfiguration",
          "tier": 1,
          "reasoning": "Named configuration type for KMS-based envelope transformer."
        },
        {
          "term": "encryption provider",
          "tier": 2,
          "reasoning": "Domain concept referring to a component that provides encryption capabilities."
        },
        {
          "term": "aesgcm",
          "tier": 2,
          "reasoning": "Configuration field name for AES-GCM transformer, a specific encryption mode."
        },
        {
          "term": "AES-GCM transformer",
          "tier": 2,
          "reasoning": "Encryption component using AES in Galois/Counter Mode for data transformation."
        },
        {
          "term": "aescbc",
          "tier": 2,
          "reasoning": "Configuration field name for AES-CBC transformer, a specific encryption mode."
        },
        {
          "term": "AES-CBC transformer",
          "tier": 2,
          "reasoning": "Encryption component using AES in Cipher Block Chaining mode for data transformation."
        },
        {
          "term": "secretbox",
          "tier": 2,
          "reasoning": "Configuration field for Secretbox-based encryption transformer."
        },
        {
          "term": "Secretbox based transformer",
          "tier": 2,
          "reasoning": "Encryption component using NaCl Secretbox for authenticated encryption."
        },
        {
          "term": "identity",
          "tier": 2,
          "reasoning": "Configuration field for identity transformer that performs no encryption."
        },
        {
          "term": "identity transformer",
          "tier": 2,
          "reasoning": "A transformer that passes data through unchanged without encryption."
        },
        {
          "term": "kms",
          "tier": 2,
          "reasoning": "Configuration field for Key Management Service based encryption."
        },
        {
          "term": "KMS based envelope transformer",
          "tier": 2,
          "reasoning": "Encryption component using external KMS for envelope encryption."
        },
        {
          "term": "envelope transformer",
          "tier": 2,
          "reasoning": "Encryption pattern where data encryption keys are wrapped by a master key."
        },
        {
          "term": "transformer",
          "tier": 2,
          "reasoning": "Domain concept for components that transform/encrypt data at rest."
        },
        {
          "term": "cache size",
          "tier": 3,
          "reasoning": "Technical parameter for KMS configuration affecting performance."
        },
        {
          "term": "configuration file",
          "tier": 3,
          "reasoning": "Technical term for file containing KMS transformer settings."
        },
        {
          "term": "apiserver-config-k8s-io-v1",
          "tier": 1,
          "reasoning": "API group and version identifier for Kubernetes API server configuration."
        },
        {
          "term": "AES-GCM",
          "tier": 3,
          "reasoning": "Advanced Encryption Standard in Galois/Counter Mode, a cryptographic algorithm."
        },
        {
          "term": "AES-CBC",
          "tier": 3,
          "reasoning": "Advanced Encryption Standard in Cipher Block Chaining mode, a cryptographic algorithm."
        },
        {
          "term": "KMS",
          "tier": 2,
          "reasoning": "Key Management Service, external service for managing encryption keys."
        }
      ],
      "term_count": 25,
      "generated_at": "2026-02-08T21:05:59.136387",
      "elapsed_time": 11.813421964645386
    },
    {
      "chunk_id": "reference_setup-tools_kubeadm_kubeadm-upgrade_sec1",
      "doc_id": "reference_setup-tools_kubeadm_kubeadm-upgrade",
      "heading": "kubeadm upgrade guidance",
      "source_file": "reference_setup-tools_kubeadm_kubeadm-upgrade.md",
      "content": "The steps for performing an upgrade using kubeadm are outlined in [this document](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/).\nFor older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.\n\nYou can use `kubeadm upgrade diff` to see the changes that would be applied to static pod manifests.\n\nIn Kubernetes v1.15.0 and later, `kubeadm upgrade apply` and `kubeadm upgrade node` will also\nautomatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.\nTo opt-out, it is possible to pass the flag `--certificate-renewal=false`. For more details about certificate\nrenewal see the [certificate management documentation](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs).\n\n{{< note >}}\nThe commands `kubeadm upgrade apply` and `kubeadm upgrade plan` have a legacy `--config`\nflag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular\ncontrol-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are\nreports of unexpected results.\n{{</ note >}}",
      "terms": [
        {
          "term": "kubeadm",
          "tier": 1,
          "reasoning": "Core Kubernetes CLI tool for cluster bootstrapping and management"
        },
        {
          "term": "kubeadm upgrade",
          "tier": 1,
          "reasoning": "Specific kubeadm subcommand for performing cluster upgrades"
        },
        {
          "term": "kubeadm upgrade diff",
          "tier": 1,
          "reasoning": "Specific kubeadm command to preview changes to static pod manifests"
        },
        {
          "term": "kubeadm upgrade apply",
          "tier": 1,
          "reasoning": "Specific kubeadm command to apply cluster upgrades"
        },
        {
          "term": "kubeadm upgrade node",
          "tier": 1,
          "reasoning": "Specific kubeadm command to upgrade a node"
        },
        {
          "term": "kubeadm upgrade plan",
          "tier": 1,
          "reasoning": "Specific kubeadm command for planning cluster upgrades"
        },
        {
          "term": "static pod manifests",
          "tier": 2,
          "reasoning": "Domain concept referring to pod definitions managed directly by kubelet"
        },
        {
          "term": "static pod",
          "tier": 2,
          "reasoning": "Core Kubernetes concept for pods managed directly by kubelet without API server"
        },
        {
          "term": "manifests",
          "tier": 2,
          "reasoning": "Technical term for Kubernetes resource definition files"
        },
        {
          "term": "Kubernetes",
          "tier": 1,
          "reasoning": "The core container orchestration platform being documented"
        },
        {
          "term": "certificates",
          "tier": 2,
          "reasoning": "Security concept for TLS/PKI certificates used in cluster authentication"
        },
        {
          "term": "certificate renewal",
          "tier": 2,
          "reasoning": "Process of renewing expiring certificates in the cluster"
        },
        {
          "term": "kubeconfig files",
          "tier": 1,
          "reasoning": "Configuration files containing cluster access credentials and settings"
        },
        {
          "term": "kubeconfig",
          "tier": 1,
          "reasoning": "Core Kubernetes configuration file format for cluster access"
        },
        {
          "term": "node",
          "tier": 2,
          "reasoning": "Fundamental Kubernetes concept representing a worker machine in the cluster"
        },
        {
          "term": "--certificate-renewal=false",
          "tier": 1,
          "reasoning": "Specific CLI flag to disable automatic certificate renewal"
        },
        {
          "term": "--config",
          "tier": 1,
          "reasoning": "CLI flag for specifying configuration during upgrade operations"
        },
        {
          "term": "cluster",
          "tier": 2,
          "reasoning": "Core architectural concept representing a set of Kubernetes nodes"
        },
        {
          "term": "control-plane node",
          "tier": 2,
          "reasoning": "Node running control plane components that manage the cluster"
        },
        {
          "term": "control-plane",
          "tier": 2,
          "reasoning": "Architectural concept for the management layer of Kubernetes"
        },
        {
          "term": "upgrade",
          "tier": 2,
          "reasoning": "Technical process of updating Kubernetes version or components"
        },
        {
          "term": "upgrade workflow",
          "tier": 2,
          "reasoning": "The defined process and steps for performing cluster upgrades"
        },
        {
          "term": "reconfigure",
          "tier": 2,
          "reasoning": "Technical operation of changing cluster configuration"
        },
        {
          "term": "certificate management",
          "tier": 2,
          "reasoning": "Domain concept for handling PKI certificates in the cluster"
        },
        {
          "term": "v1.15.0",
          "tier": 3,
          "reasoning": "Specific Kubernetes version reference indicating feature availability"
        },
        {
          "term": "flag",
          "tier": 3,
          "reasoning": "Technical term for command-line options passed to CLI tools"
        }
      ],
      "term_count": 26,
      "generated_at": "2026-02-08T21:06:14.238454",
      "elapsed_time": 14.094237565994263
    },
    {
      "chunk_id": "tasks_configure-pod-container_configure-pod-configmap_sec18",
      "doc_id": "tasks_configure-pod-container_configure-pod-configmap",
      "heading": "{{% heading \"cleanup\" %}}",
      "source_file": "tasks_configure-pod-container_configure-pod-configmap.md",
      "content": "Delete the ConfigMaps and Pods that you made:\n\n```bash\nkubectl delete configmaps/game-config configmaps/game-config-2 configmaps/game-config-3 \\\n               configmaps/game-config-env-file\nkubectl delete pod dapi-test-pod --now",
      "terms": [
        {
          "term": "ConfigMaps",
          "tier": 1,
          "reasoning": "Kubernetes API object for storing configuration data as key-value pairs, explicitly named in the delete command."
        },
        {
          "term": "Pods",
          "tier": 1,
          "reasoning": "Core Kubernetes API object representing the smallest deployable unit, explicitly mentioned in the section header."
        },
        {
          "term": "kubectl",
          "tier": 1,
          "reasoning": "Official Kubernetes CLI tool used to interact with the cluster, shown executing delete commands."
        },
        {
          "term": "kubectl delete",
          "tier": 1,
          "reasoning": "Specific kubectl subcommand for removing Kubernetes resources from the cluster."
        },
        {
          "term": "configmaps/game-config",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference using type/name notation in kubectl command."
        },
        {
          "term": "configmaps/game-config-2",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference demonstrating multiple resource deletion."
        },
        {
          "term": "configmaps/game-config-3",
          "tier": 1,
          "reasoning": "Specific ConfigMap resource reference in the batch delete operation."
        },
        {
          "term": "configmaps/game-config-env-file",
          "tier": 1,
          "reasoning": "ConfigMap resource created from environment file, indicated by naming convention."
        },
        {
          "term": "pod",
          "tier": 1,
          "reasoning": "Kubernetes resource type specified in the delete command for dapi-test-pod."
        },
        {
          "term": "dapi-test-pod",
          "tier": 1,
          "reasoning": "Specific named Pod resource being deleted, likely used for Downward API testing based on naming."
        },
        {
          "term": "delete",
          "tier": 2,
          "reasoning": "Kubernetes operation for removing resources from the cluster, core lifecycle management concept."
        },
        {
          "term": "--now",
          "tier": 2,
          "reasoning": "kubectl flag that forces immediate deletion by setting grace period to zero, bypassing graceful termination."
        },
        {
          "term": "bash",
          "tier": 3,
          "reasoning": "Shell environment indicated by the code block annotation, context for command execution."
        },
        {
          "term": "game-config",
          "tier": 2,
          "reasoning": "ConfigMap name pattern used in the example, representing application configuration resource."
        },
        {
          "term": "env-file",
          "tier": 2,
          "reasoning": "Configuration pattern indicated in resource name, referring to environment file-based ConfigMap creation."
        }
      ],
      "term_count": 15,
      "generated_at": "2026-02-08T21:06:25.429999",
      "elapsed_time": 10.18539571762085
    }
  ]
}